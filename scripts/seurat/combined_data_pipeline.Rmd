---
author: "Céline Chevalier, Anaïs Baudot, Fabienne Lescroart, Laurent Argiro, Stéphane Zaffran"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output:
    html_document:
        theme:
            bootswatch: yeti
        toc: yes
        toc_float:
          collapsed: false
          smooth_scroll: true
        number_sections: yes
        df_print: kable
        code_folding: hide
    pdf_document:
        number_sections: yes
        toc: yes
        toc_depth: 3
        keep_tex: no
params:
    analysis.name:
        value: "analysis_"
    new.analysis:
        value: FALSE
    dataset:
        value: NA
        choices: [lab_3_days, lab_4_days]
    do.integ:
        value: FALSE
    do.merge:
        value: FALSE
    hvg.meth:
        value: mvp
        choices: [vst, mvp, disp]
    hvg.num:
        value: FALSE
    do.scale:
        value: FALSE
    pca.npcs:
        value: 50
    pca.print:
        value: 10
    top.pcs:
        value: 30
    res:
        value: 1.0
    algo.cluster:
        value: 4
        choices: [1, 2, 3, 4]
    top.markers:
        value: 20
    general.seed:
        value: 17
    combine.meth:
        value: NA
        choices: [merged, blkS, blkH, seqS]
title: |
    | Protocole 2:
    | Combined datasets analysis
    | `r params$dataset`
---

<!-- Javascript for zooming on figures (adapted from: https://stackoverflow.com/questions/40401680) -->

<!-- Jquery import conflicts with DT::datatable so needs to be commented here -->
<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script> -->

<style>
.zoomDiv {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  z-index: 50;
  transform: translate(-50%, -50%);
  background-color: #FFFFFF;
  box-shadow: 0px 0px 50px #888888;
  width: fit-content;
  max-width: 90%;
  max-height: 90%;
  overflow: auto;
}

.zoomImg {
  width: 150%;
}
</style>

<script type="text/javascript">
  $(document).ready(function() {
    $('body').prepend("<div class=\"zoomDiv\"><img src=\"\" class=\"zoomImg\"></div>");
    // onClick for all img except the zoomed one and link ones (filter)
    // use 'img.zoom' and out.extra='class=\"zoom\"' in chunk to specify manually which chunk images can be zoomed
    $('img:not(.zoomImg)').filter(':not(a *)').click(function() {
      $('.zoomImg').attr('src', $(this).attr('src'));
      $('.zoomDiv').show();
    })
    // onClick function for hiding div
    $('img.zoomImg').click(function() {
      $('.zoomDiv').hide();
    })
  })
</script>

```{r setup1, eval=TRUE, include=FALSE}
options(knitr.purl.inline = TRUE)
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,

    # text output
    echo = TRUE,
  results = 'hold',
    warning = FALSE,
    error = FALSE,
    message = FALSE,
    strip.white = TRUE,

    # code decoration
    #tidy = TRUE,
    tidy.opts = list(width.cutoff = 90),
    comment = '',
    attr.output='.numberLines',
    
    # plots
    #fig.path = "figure/",      # is set later, in chunk setup2
    fig.show = "asis",         # tuned to "hold" in multiple plots chunk
    dev = c('png', 'pdf'),
    fig.width = 10,
    fig.height = 10,
    #fig.asp=1.3               # fig.height = fig.width * fig.asp
    #out.extra = 'style="border:5px solid orange"'     # orange box arround plots
    fig.align = "center"       # should be tuned to default in multiple plots chunk
)
```

```{r load-lib, include=FALSE}
library(dplyr)
library(Matrix)
library(Seurat)
library(ggplot2)
library(reticulate)
library(scmap)
library(RColorBrewer)
library(harmony)
library(stringr)
library(kableExtra)
library(formattable)
library(knitr)
library(SingleCellExperiment)
library(BiocGenerics)
library(scales)
library(formatR)
library(uwot)
library(DT)
library(patchwork)
library(ggrepel)
```

```{r get-params, include=FALSE}
bindingIsLocked("params", env = .GlobalEnv)
unlockBinding("params", env = .GlobalEnv)
attach(params)
set.seed(general.seed)
```

```{r sourceCodes}
source("./utilities/extract_topn.R")
source("./utilities/add_dominantMetadata.R")
source("./utilities/additionalPlots.R")
source("./utilities/00_generalDeps.R")
```


# Global settings {.tabset .tabset-pills .tabset-fade}

## `r dataset` analysis settings

```{r show-params}
ul <- unlist(params)
df <- data.frame(keyName=names(ul), value=ul, row.names=NULL)
names(df) <- c('Parameters', 'Values')
df1 <- df[1:ceiling(dim(df)[1]/3),]
df1$Parameters <- cell_spec(df1$Parameters, bold = T)
df2 <- df[(ceiling(dim(df)[1]/3)+1):(2*ceiling(dim(df)[1]/3)),]
df2$Parameters <- cell_spec(df2$Parameters, bold = T)
df3 <- df[((2*ceiling(dim(df)[1]/3))+1):dim(df)[1],]
df3$Parameters <- cell_spec(df3$Parameters, bold = T)


list(df1, df2, df3) %>%
  knitr::kable(align = "ll", row.names = FALSE, escape = F) %>% 
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE)
rm(df)
```


## Directories

Set either input and output directories.

```{r base-path}
#basePath <- "/home/celine/temp2"
#basePath <- "/mnt/DATA_4TB/projects/gastruloids_sc_Lescroart/analysis/seuratAnalysis" # local server
basePath <- "/shared/projects/mothard_in_silico_modeling/seurat_analysis" # IFB server
```

### Input directories

Get the path of the inputs used for the analysis:

- atlas.folder

- inputTables.folder

- otherInputs

```{r input-dirs}
inputs.folder <- file.path(basePath, "inputData")

atlas.folder <- file.path(inputs.folder, "atlas")
inputTables.folder <- file.path(inputs.folder, "InputTables")
otherInputs <- file.path(inputs.folder, "other")
```

### Output directories

Create or reuse directories (if already existing) to store the outputs such as
figures, tables and reports.

```{r anteriority, eval=(analysis.name == "analysis_"), echo=(analysis.name == "analysis_")}
last_analysis <- 0
dirs.in.dir <- list.dirs(basePath, full.names = FALSE, recursive = FALSE)
anterior <- grep("^analysis_[0-9]+", dirs.in.dir, value = TRUE)
#anterior <- grep("st", dirs.in.dir, value = TRUE)
if (length(anterior) > 0){
    last_analysis <- max(as.numeric(str_extract_all(anterior, "\\d+", simplify = TRUE)), na.rm=T)
} else {
    params$new.analysis <- TRUE
    attach(params)
}
```

```{r default_analysisName, eval=(!new.analysis && analysis.name == "analysis_"), echo=(!new.analysis && analysis.name == "analysis_")}
analysis.name <- paste0(analysis.name, as.character(last_analysis))
```

```{r reAnalysis, eval=!new.analysis, echo=!new.analysis}
baseAnalysis <- file.path(basePath, analysis.name)
rdsObjects <- file.path(baseAnalysis, "rdsObjects")
if(!dir.exists(rdsObjects)){dir.create(rdsObjects)}
```


```{r dataset-analysisFolder}
dataset.anFolder <- file.path(baseAnalysis, paste0(dataset, "_", combine.meth))
if(!dir.exists(dataset.anFolder)){dir.create(dataset.anFolder)}
fig.folder <- file.path(dataset.anFolder, "figures/")
if(!dir.exists(fig.folder)){dir.create(fig.folder)}
```

```{r setup2, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    
    # figures
    fig.path = fig.folder
)
```

## Set up color vectors

Load table to in which colors are defined for the labels used in the analysis.

```{r load_colorTables}
colors.table <- read.table(file=file.path(inputTables.folder, "ClusterColors.tsv"), sep="\t", header=T, comment.char="", as.is=T)
colors.celltype <- setNames(colors.table$blind_friendly[!is.na(colors.table$transferred_identity)], colors.table$transferred_identity[!is.na(colors.table$transferred_identity)])
colors.stage <- setNames(c("#bb573b", "#ac9d3e", "#5aaf6a", "#7564b9", "#b94c84", "#ba4b7d", "#90b03d", "#60a756", "#45c097", "#5e8bd5", "#6d71d8", "#573585", "#bd80d5", "#b853a2", "#ba4b7d"), c("Day_04", "Day_05", "Day_06", "Day_07", "Day_10", "Day_11", "E6.5", "E6.75", "E7.0", "E7.25", "E7.5", "E7.75", "E8.0", "E8.25", "E8.5"))
```

```{r starter, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
sep_data <- grep("^03_", list.files(rdsObjects, full.names = FALSE, recursive = FALSE), value = TRUE)
sep_days <- sort(str_extract(sep_data, "lab_day_[0-9]{2}"))
```

# Get `r dataset` data

## Load the data

Take data previously generated during single dataset pipeline execution.

```{r multiple-load}
if (dataset == "lab_3_days") {
    
    sep_data.list <- lapply(sep_days[1:3], function(day){
        
        toLoad_SO <- grep(day, sep_data, value = TRUE)
        SO <- readRDS(file = file.path(rdsObjects, toLoad_SO))
        celltypes <- read.table(
            file = file.path(baseAnalysis, day, paste0("cellIdentitiesPredictions_final_", day, ".csv")),
            sep = ",",
            header = TRUE)
        # umap2d <- read.table(
        #     file = file.path(baseAnalysis, day, paste0("final_umap2Dcoordinates_", day, ".csv")),
        #     sep = ",",
        #     header = TRUE)
        # SO[["umap2d"]] <- CreateDimReducObject(embeddings = as.matrix(umap2d), key = "UMAP2d_")
        SO <- AddMetaData(SO, metadata = celltypes$predicted.id, col.name = "orig.celltype")
    })
    
    names(sep_data.list) <- sep_days[1:3]
    
    
} else if (dataset == "lab_4_days") {
    
    sep_data.list <- lapply(sep_days, function(day){
        
        toLoad_SO <- grep(day, sep_data, value = TRUE)
        SO <- readRDS(file = file.path(rdsObjects, toLoad_SO))
        celltypes <- read.table(
            file = file.path(baseAnalysis, day, paste0("cellIdentitiesPredictions_final_", day, ".csv")),
            sep = ",",
            header = TRUE)
        SO <- AddMetaData(SO, metadata = celltypes$predicted.id, col.name = "orig.celltype")
        # umap2d <- read.table(
        #     file = file.path(baseAnalysis, day, paste0("final_umap2Dcoordinates_", day, ".csv")),
        #     sep = ",",
        #     header = TRUE)
        # SO[["umap2d"]] <- CreateDimReducObject(embeddings = as.matrix(umap2d), key = "UMAP2d_", assay = DefaultAssay(SO))
    })
    
    names(sep_data.list) <- sep_days
}

sep_data.list
```

```{r integrate-sep-data, eval=do.integ, echo=do.integ}
set.seed(general.seed)

if (combine.meth == "blkH"){
    SO <- merge(x = sep_data.list[[1]], y = sep_data.list[2:length(sep_data.list)], merge.data = T)
    
} else if (combine.meth == "blkS"){
    features <- SelectIntegrationFeatures(object.list = sep_data.list)
    anchors <- FindIntegrationAnchors(object.list = sep_data.list, anchor.features = features)
    SO <- IntegrateData(anchorset = anchors)
    
} else if (combine.meth == "seqS"){
    SO <- sep_data.list[[1]]
    names(sep_data.list) <- c("Days04", "Day_05", "Day_06", "Day_11")
    for (a_day in names(sep_data.list)[2:length(sep_data.list)]){
        integ.list <- list(SO, sep_data.list[[a_day]])
        features <- SelectIntegrationFeatures(integ.list)
        anchors <- FindIntegrationAnchors(object.list = integ.list,
                                          anchor.features = features)
        SO <- IntegrateData(anchorset = anchors)
    } 
}

rm(sep_data, toLoad_data, sep_data.list)
invisible(gc())
```

```{r merge-sep-data, eval=do.merge, echo=do.merge}
SO <- merge(x = sep_data.list[[1]], y = sep_data.list[2:length(sep_data.list)], merge.data = T)
SO

rm(sep_data, sep_data.list)
invisible(gc())
```

## Remove/show metadata

```{r rm-metadata}
SO$seurat_clusters <- NULL
SO@meta.data[grep("pANN", colnames(SO@meta.data), value = TRUE)] <- NULL
SO@meta.data[grep("RNA_snn", colnames(SO@meta.data), value=TRUE)] <- NULL


data.frame(head(SO@meta.data)) %>%
  knitr::kable(align = "lrrrrrr",
               caption = paste0("6 first lines of the ", dataset, " metadata table")) %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")
```

```{r save1}
saveRDS(SO, file=file.path(rdsObjects, paste0("04_multiTP_", dataset, "_", combine.meth, ".rds")))
```

```{r setup3, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart1}
SO <- readRDS(file.path(rdsObjects, paste0("04_multiTP_", dataset, "_", combine.meth, ".rds")))
sep_data <- grep("^07_", list.files(rdsObjects, full.names = FALSE, recursive = FALSE), value = TRUE)
sep_data <- sep_data[c(1:2,4:5)]
sep_days <- sort(str_extract(sep_data, "lab_day_[0-9]{2}"))
```

```{r setup4, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  echo = TRUE
)
```

## Nomenclature for cell names

```{r cells_nomenclature}
head(colnames(SO), 4)
```

Below, we can see that there are as many unique cell identifiers as the number of cells.

Number of cells in the dataset: `r dim(SO)[2]`

Number of unique cell identifiers: `r length(unique(colnames(SO)))`


- - -

\clearpage

# Preprocessing workflow

```{r hvg-vst2, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp", message=TRUE}
SO <- FindVariableFeatures(SO, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)

var.feats.dataset <- VariableFeatures(SO)
saveRDS(var.feats.dataset, file=file.path(rdsObjects, paste0("var.feats.dataset_", dataset, "_", combine.meth, ".rds")))
SO <- ScaleData(SO, features=rownames(SO), do.scale=do.scale, verbose=FALSE)
SO <- RunPCA(SO, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)

if (combine.meth == "blkH"){
    SO <- RunHarmony(SO, "day", plot_convergence = FALSE)
}
SO <- RunUMAP(SO, reduction = ifelse( combine.meth == "blkH", "harmony", "pca"), dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE)
resolutions <- c(seq(0.1, 0.4, 0.1), seq(0.6, 1.6, 0.2))
SO <- FindNeighbors(SO, reduction = ifelse( combine.meth == "blkH", "harmony", "pca"), dims = 1:top.pcs, verbose=FALSE)
SO <- FindClusters(SO, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
```

```{r hvg-mvp2, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp", message=TRUE}
SO <- FindVariableFeatures(SO, selection.method = hvg.meth, verbose=FALSE)
head(SO@assays[[DefaultAssay(SO)]]@meta.features) %>%
  knitr::kable(caption = "Example of HVG selection output") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

t(as.data.frame(table(SO@assays[[DefaultAssay(SO)]]@meta.features$mvp.variable))) %>%
  knitr::kable(caption = "Number of features selected as highly variable genes (HVG)",
               row.names = FALSE,
               escape = F,
               align = "cc") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

var.feats.dataset <- VariableFeatures(SO)
saveRDS(var.feats.dataset, file=file.path(rdsObjects, paste0("var.feats.dataset_", dataset, "_", combine.meth, ".rds")))
SO <- ScaleData(SO, features=rownames(SO), do.scale=do.scale, verbose=FALSE)
SO <- RunPCA(SO, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)

if (combine.meth == "blkH"){
    SO <- RunHarmony(SO, "day", plot_convergence = FALSE)
}
SO <- RunUMAP(SO, dims = 1:top.pcs, reduction = ifelse( combine.meth == "blkH", "harmony", "pca"), seed.use = general.seed, verbose = FALSE)
resolutions <- c(seq(0.1, 0.4, 0.1), seq(0.6, 1.6, 0.2))
SO <- FindNeighbors(SO, reduction = ifelse( combine.meth == "blkH", "harmony", "pca"), dims = 1:top.pcs, verbose=FALSE)
SO <- FindClusters(SO, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
```

```{r plot-elbow2, eval=FALSE, echo=FALSE}
ElbowPlot(SO, ndims = pca.npcs) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color = "purple", size = 1) +
  ggtitle(paste0(dataset, "\nElbowPlot"))
```

```{r plot-clusters-1, out.width="50%", results='asis', eval=FALSE, echo=FALSE}
invisible(sapply(resolutions, function(ares)
{
    cat("## Res.  ", ares, "\n")
    
    clusterResName <- grep(paste0(DefaultAssay(SO), "_snn_res.", ares, "$"), colnames(SO@meta.data), value = TRUE)
    Idents(SO) <- clusterResName
    
    print(DimPlot(SO,
                   pt.size = 1,
                   label = TRUE,
                   label.size = 6,
                   repel = TRUE) +
               NoLegend() +
               ggtitle(paste0(dataset, " : clusters at resolution ", ares)) +
               theme(plot.title = element_text(hjust = 0.5),
                     axis.text = element_blank(),
                     line = element_blank())
    )
    
    cat(" \n \n") # Required for '.tabset'
}))
```

```{r save2}
saveRDS(SO, file=file.path(rdsObjects, paste0("05_preprocessing_", dataset, "_", combine.meth, ".rds")))
invisible(gc())
```

- - -

\clearpage

# Atlas loading

```{r load-atlas, message=TRUE}
# rdsObject generated by the code atlas_mergedIntegration.R
# the file is considered as an inputs of the atlas
atlas.subset <- readRDS(file.path(atlas.folder, "atlas_preprocessed.rds"))
invisible(gc())
```

```{r setup5, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart3integ}
SO <- readRDS(file.path(rdsObjects, paste0("05_preprocessing_", dataset, "_", combine.meth, ".rds")))
var.feats.dataset <- readRDS(file.path(rdsObjects, paste0("var.feats.dataset_", dataset, "_", combine.meth, ".rds")))
atlas.subset <- readRDS(file.path(atlas.folder, "atlas_preprocessed.rds"))
sep_data <- grep("^03_", list.files(rdsObjects, full.names = FALSE, recursive = FALSE), value = TRUE)
sep_days <- sort(str_extract(sep_data, "lab_day_[0-9]{2}"))
rm(sep_data)
invisible(gc())
```

```{r setup6, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

- - -

\clearpage

# Transfer learning from the Atlas

## Cell identity transfer {.tabset .tabset-pills .tabset-fade}

### Dimplot of the predicted celltypes

```{r mapping-atlas2, results='hide', out.width="50%"}
anchors <- FindTransferAnchors(reference = atlas.subset, query = SO,
                               dims = 1:top.pcs, reference.reduction = "pca")
predictions <- TransferData(anchorset = anchors, refdata = atlas.subset$celltype,
                            dims = 1:top.pcs)

SO <- AddMetaData(SO, metadata = predictions[,"predicted.id"], col.name = 'celltype')

write.table(x = predictions, file = file.path(dataset.anFolder,
                                               paste0("cellIdentitiesPredictions_multiTP_", 
                                                      dataset, "_", combine.meth, ".csv")), sep = ",", row.names = F, col.names = T)

rm(predictions)
invisible(gc())

Idents(SO) <- SO@meta.data$celltype
DimPlot(SO,
        pt.size = 1,
        repel = TRUE,
        label = TRUE,
        label.size = 6,
        cols = colors.celltype[levels(Idents(SO))]) +
  ggtitle(paste0(dataset, " : cell identity predictions after combining datasets")) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        line = element_blank()) +
        NoLegend()
```

```{r setup9, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart4}
SO <- readRDS(file.path(rdsObjects, paste0("09_preprocessing_", dataset, "_", combine.meth, ".rds")))
atlas.subset <- readRDS(file.path(atlas.folder, "atlas_preprocessed.rds"))
var.feats.dataset <- readRDS(file.path(rdsObjects, paste0("var.feats.dataset_", dataset, "_", combine.meth, ".rds")))
predictions <- read.table(file.path(dataset.anFolder, paste0("cellIdentitiesPredictions_final_", dataset, "_", combine.meth, ".csv")), sep = ",", header = T)
SO <- AddMetaData(SO, metadata = predictions[,"predicted.id"], col.name = "celltype")

rm(predictions)
invisible(gc())

Idents(SO) <- SO@meta.data$celltype
DimPlot(SO,
        pt.size = 1,
        repel = TRUE,
        label = TRUE,
        label.size = 6,
        cols = colors.celltype[levels(Idents(SO))]) +
  ggtitle(paste0(dataset, " : cell identities on integrated multi TP")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        line = element_blank()) +
        NoLegend()
```

```{r setup10, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

### Facets of the predicted celltypes

```{r plot-DF-celltype-facets, fig.height = 20}
cellsData <- data.frame(SO@reductions[["umap"]]@cell.embeddings, SO@meta.data$celltype)
colnames(cellsData) <- c(colnames(SO@reductions[["umap"]]@cell.embeddings), "celltype")

ggplot(cellsData[c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP_1,
              y = UMAP_2)) +
    geom_point( alpha = .4,
                size  = .75,
                color = "grey") +
    geom_point( data = cellsData, # Now provide data including column for facetting
                aes(color = celltype),
                alpha = .5,
                size  = 1.2) +
    scale_fill_manual(values = colors.celltype[SO@meta.data$celltype], aesthetics = "color") +
    facet_wrap(facets = vars(celltype),
               ncol = 3) +
    NoLegend() +
    ggtitle(paste0(dataset, " : cell identities facets")) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank())
```

### Heatmap of predicted celltypes before vs. after datasets combination
Impact of the integration of the longitudinal data on the label transfer.

```{r heatmap-singleVSmultiTP}
Idents(SO) <- SO@meta.data$day
day <- NULL
transition <- table(SO@meta.data[WhichCells(SO, idents = day), 'orig.celltype'], SO@meta.data[WhichCells(SO, idents = day), 'celltype'])
dt <- as.data.frame(transition, row.names = names(SO@meta.data[WhichCells(SO, idents = day), 'celltype']))
dt[dt == 0] <- NA
names(dt) <- c("singleAnn", "combinedAnn", "counts")

ggplot(dt, aes(singleAnn, combinedAnn, fill = counts)) + # nolint
    geom_tile() +
    geom_text(aes(label = counts), color = "black", size = 2.5, fontface = "bold") +
    #scale_color_manual(values = c(NA, "black"), na.value = NA) +
    coord_fixed() +
    scale_fill_gradient(low = "white", high = "pink", na.value="white") +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
    guides(fill = guide_colourbar(barwidth = 0.5,
                                  barheight = 10,
                                  title = "Counts")) +
    ggtitle(paste0(dataset, "\nLabel transfer consistency between single TP and multi TP label transfers")) +
    CenterTitle() +
    labs(x = "Celltype annotation on the single datasets", y = paste0("Celltype annotation on the ", length(sep_days), " combined datasets"))
```


```{r heatmap-singleVSmultiTP-daily, out.width="50%", fig.align='default'}
invisible(sapply(levels(as.factor(SO@meta.data$day)), function(x) {
    day <- x
    transition <- table(SO@meta.data[WhichCells(SO, idents = day), 'orig.celltype'], SO@meta.data[WhichCells(SO, idents = day), 'celltype'])
    dt <- as.data.frame(transition, row.names = names(SO@meta.data[WhichCells(SO, idents = day), 'celltype']))
    dt[dt == 0] <- NA
    names(dt) <- c("singleAnn", "combinedAnn", "counts")

    print(ggplot(dt, aes(singleAnn, combinedAnn, fill = counts)) + # nolint
        geom_tile() +
        geom_text(aes(label = counts), color = "black", size = 2.5, fontface = "bold") +
        #scale_color_manual(values = c(NA, "black"), na.value = NA) +
        coord_fixed() +
        scale_fill_gradient(low = "white", high = "pink", na.value="white") +
        theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
        guides(fill = guide_colourbar(barwidth = 0.5,
                                      barheight = 10,
                                      title = "Counts")) +
        ggtitle(paste0(x, "\nLabel transfer consistency between single TP and integrated TP label transfers")) +
        CenterTitle() +
        labs(x = paste0("Celltype annotation on the single ", x, " dataset"), y = paste0("Celltype annotation on the combined ", dataset, " dataset")))
}))
```

<!-- ## Global orientation of the UMAP plots {.tabset .tabset-pills .tabset-fade} -->
<!--  -->
<!-- ### Integrated data with the atlas {.tabset .tabset-pills .tabset-fade} -->
<!--  -->
<!-- ```{r integration-with-atlas} -->
<!-- features <- SelectIntegrationFeatures(object.list = list(SO, atlas.subset)) -->
<!-- anchors <- FindIntegrationAnchors(object.list = list(SO, atlas.subset), anchor.features = features) -->
<!-- SO.align <- IntegrateData(anchorset = anchors) -->
<!--  -->
<!-- SO.align@project.name <- paste0(dataset, "_with_atlas") -->
<!-- DefaultAssay(SO.align) <- "integrated" -->
<!--  -->
<!-- SO.align <- ScaleData(SO.align, assay = DefaultAssay(SO.align), do.scale=do.scale, verbose = FALSE) -->
<!-- SO.align <- RunPCA(SO.align, npcs = pca.npcs, verbose = FALSE) -->
<!-- SO.align <- RunUMAP(SO.align, dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE) -->
<!-- ``` -->
<!--  -->
<!-- #### Facet Atlas versus Gastruloids -->
<!--  -->
<!-- ```{r facet-atlasVSgast, out.width="50%"} -->
<!-- Idents(SO.align) <- "model" -->
<!-- cellsData <- data.frame(SO.align@reductions[["umap"]]@cell.embeddings, SO.align@meta.data$model) -->
<!-- colnames(cellsData) <- c(colnames(SO.align@reductions[["umap"]]@cell.embeddings), "model") -->
<!-- ggplot(cellsData[c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets -->
<!--          aes( x = UMAP_1, -->
<!--               y = UMAP_2)) + -->
<!--     geom_point( alpha = .4, -->
<!--                 size  = 1, -->
<!--                 color = "grey") + -->
<!--     geom_point( data = cellsData, # Now provide data including column for facetting -->
<!--                 aes(color = model), -->
<!--                 alpha = .5, -->
<!--                 size  = 1.2) + -->
<!--     facet_wrap(facets = vars(factor(model, levels = c("Embryos", "Gastruloids"))), -->
<!--                ncol = 2) + -->
<!--     theme_void() + -->
<!--     NoLegend() + -->
<!--     ggtitle(paste0(dataset, " : atlas cells (as Embryos)\n and gastruloids after integration")) + -->
<!--     theme(plot.title = element_text(hjust = 0.5), -->
<!--           axis.text = element_blank(), -->
<!--           line = element_blank()) -->
<!-- ``` -->
<!--  -->
<!-- #### Stages in the Atlas dataset -->
<!--  -->
<!-- ```{r atlasStages-integWithData, out.width="50%"} -->
<!-- Idents(SO.align) <- "day" -->
<!-- cellsData <- data.frame(SO.align@reductions[["umap"]]@cell.embeddings, SO.align@meta.data$model, SO.align@meta.data$day) -->
<!-- colnames(cellsData) <- c(colnames(SO.align@reductions[["umap"]]@cell.embeddings), "model", "day") -->
<!--  -->
<!-- ggplot(cellsData[c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets -->
<!--          aes( x = UMAP_1, -->
<!--               y = UMAP_2)) + -->
<!--     geom_point( alpha = .4, -->
<!--                 size  = 1, -->
<!--                 color = "grey") + -->
<!--     geom_point( data = cellsData[cellsData$model == "Embryos",], # Now provide data including column for facetting -->
<!--                 aes(color = day), -->
<!--                 alpha = .5, -->
<!--                 size  = 1.2) + -->
<!--     scale_fill_manual(values = colors.stage[cellsData[cellsData$model == "Embryos", "day"]], -->
<!--                       aesthetics = "color", -->
<!--                       breaks = sort(levels(as.factor(cellsData[cellsData$model == "Embryos", "day"]))), -->
<!--                       name = "Stages") + -->
<!--     theme_void() + -->
<!--     ggtitle("Atlas stages") + -->
<!--     theme(plot.title = element_text(hjust = 0.5), -->
<!--           axis.text = element_blank(), -->
<!--           line = element_blank(), -->
<!--           legend.position = "bottom") + -->
<!--     guides(colour = guide_legend(override.aes = list(size=8, alpha = 1))) -->
<!-- ``` -->
<!--  -->
<!-- #### Facet celltypes of the Atlas -->
<!--  -->
<!-- ```{r facet-atlasCelltypes, fig.height=30} -->
<!-- Idents(SO.align) <- "celltype" -->
<!-- cellsData <- data.frame(SO.align@reductions[["umap"]]@cell.embeddings, SO.align@meta.data$celltype, SO.align@meta.data$model) -->
<!-- colnames(cellsData) <- c(colnames(SO.align@reductions[["umap"]]@cell.embeddings), "celltype", "model") -->
<!-- ggplot(cellsData[cellsData$model == "Embryos", c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets -->
<!--          aes( x = UMAP_1, -->
<!--               y = UMAP_2)) + -->
<!--     geom_point( alpha = .4, -->
<!--                 size  = .75, -->
<!--                 color = "grey") + -->
<!--     geom_point( data = cellsData[cellsData$model == "Embryos",], # Now provide data including column for facetting -->
<!--                 aes(color = celltype), -->
<!--                 alpha = .5, -->
<!--                 size  = 1.2) + -->
<!--     scale_fill_manual(values = colors.celltype[SO.align@meta.data$celltype], aesthetics = "color") + -->
<!--     facet_wrap(facets = vars(celltype), -->
<!--                ncol = 3) + -->
<!--     theme_void() + -->
<!--     NoLegend() + -->
<!--     ggtitle(paste0("Atlas cell identity facets\n", dataset)) + -->
<!--     theme(plot.title = element_text(hjust = 0.5), -->
<!--           axis.text = element_blank(), -->
<!--           line = element_blank()) -->
<!-- ``` -->
<!--  -->
<!--  -->
<!-- ### UMAP of a subset of the atlas -->
<!--  -->
<!-- UMAP dimension reduction on atlas, with 200 cells per celltype, 300 neighbors -->
<!--  -->
<!-- ```{r atlas_refLayout, out.width="50%"} -->
<!-- spread <- 2 -->
<!-- min_dist <- 1 -->
<!-- Idents(atlas.subset) <- 'celltype' -->
<!--  -->
<!-- # Downsample the number of cells per identity class -->
<!-- set.seed(general.seed) -->
<!-- cells.use <- WhichCells(object = atlas.subset, downsample = 200) #colnames(atlas.subset) #sample(colnames(atlas.subset),1000) -->
<!-- nn=300 -->
<!-- local_connectivity=1 # Tried 2 and was not so convincing. Should not be more than the local intrinsic dimension of the manifold. -->
<!-- fast_sgd <- F # Should set it to FALSE ultimately, to get exactly reproducible results, but TRUE can be useful as it is faster for early exploration. -->
<!-- umap_init <- "spectral" # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates. -->
<!-- reduction.use <- "pca" -->
<!--  -->
<!-- set.seed(general.seed) -->
<!-- tmp <- umap(X = Embeddings(atlas.subset[[reduction.use]])[cells.use, 1:top.pcs], -->
<!--             init = umap_init, -->
<!--             n_neighbors = nn, -->
<!--             n_components = 3, -->
<!--             metric = "cosine", -->
<!--             min_dist = min_dist, -->
<!--             spread = spread, -->
<!--             init_sdev = 1e-4, -->
<!--             local_connectivity = local_connectivity, -->
<!--             ret_model=T, -->
<!--             verbose = F) -->
<!-- tmp2 <- 0*Embeddings(atlas.subset[[reduction.use]])[, 1:3] -->
<!-- tmp2[cells.use, ] <- tmp$embedding -->
<!-- atlas.subset[["umap200"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP200_") -->
<!--  -->
<!-- DimPlot(atlas.subset, pt.size = 1, reduction = "umap200", label = TRUE, cells = sample(cells.use), -->
<!--         repel = TRUE, cols = colors.celltype[levels(Idents(atlas.subset))]) + -->
<!--   NoLegend() + -->
<!--   ggtitle(paste0(dataset, " : atlas celltypes\nvisualization reduced to 200 cells per celltype")) + -->
<!--   CenterTitle() + -->
<!--   NoAxes() -->
<!--  -->
<!-- coordAtlas200 <- as.data.frame(Embeddings(atlas.subset[, cells.use], reduction = "umap200")) -->
<!-- write.table(x = coordAtlas200, file = file.path(dataset.anFolder, -->
<!--                                                paste0("init_umap200Atlas_",  -->
<!--                                                       dataset, "_", combine.meth, ".csv")), sep = ",", row.names = TRUE, col.names = TRUE) -->
<!-- ``` -->
<!--  -->
<!-- ### Centroid table on atlas celltypes in the subsetted space -->
<!--  -->
<!-- ```{r atlas_cluster_avg.pos} -->
<!-- Idents(atlas.subset) <- atlas.subset$celltype -->
<!-- x_ref <- data.frame(row.names = unique(atlas.subset$celltype)) -->
<!--  -->
<!-- for(i in unique(atlas.subset$celltype)){ -->
<!--   x_ref[i,1] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),1]) -->
<!--   x_ref[i,2] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),2]) -->
<!--   x_ref[i,3] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),3]) -->
<!-- } -->
<!--  -->
<!-- # x_ref$celltype <- rownames(x_ref) -->
<!-- # colnames(x_ref) <- c("umap200_1", "umap200_2", "umap200_3", "celltype") -->
<!-- # ggplot(x_ref, aes(x=umap200_1, y=umap200_2, colour=celltype)) + -->
<!-- #     geom_point(size = 15, alpha=0.7) + -->
<!-- #     scale_color_manual(values = colors.celltype[levels(Idents(atlas.subset))]) + -->
<!-- #     NoLegend() + -->
<!-- #     geom_label_repel(aes(label=celltype), -->
<!-- #                      box.padding   = 0.1) -->
<!-- ``` -->
<!--  -->
<!-- ### Create random initial coordinates for the integrated object based on the centroid table -->
<!--  -->
<!-- ```{r UMAPinit_sharedLayout} -->
<!-- min_dist <- 8 -->
<!-- spread <- 25 -->
<!-- nn <- 300 -->
<!--  -->
<!-- # Generate a random position around the layout defined positions for all cells according to their cell types: -->
<!-- noise <- 5 -->
<!-- set.seed(general.seed) -->
<!-- x_ini <- data.frame(row.names = colnames(SO.align)) -->
<!-- x_ini[,1] <- runif(length(colnames(SO.align)))*noise -->
<!-- x_ini[,2] <- runif(length(colnames(SO.align)))*noise -->
<!-- x_ini[,3] <- runif(length(colnames(SO.align)))*noise -->
<!-- Idents(SO.align) <- SO.align$celltype -->
<!-- for(i in unique(SO.align$celltype)){ -->
<!--   if(i %in% rownames(x_ref)){ -->
<!--     x_ini[WhichCells(SO.align,idents=i),1] <- x_ini[WhichCells(SO.align,idents=i),1]+x_ref[i,1] -->
<!--     x_ini[WhichCells(SO.align,idents=i),2] <- x_ini[WhichCells(SO.align,idents=i),2]+x_ref[i,2] -->
<!--     x_ini[WhichCells(SO.align,idents=i),3] <- x_ini[WhichCells(SO.align,idents=i),3]+x_ref[i,3] -->
<!--   } -->
<!-- } -->
<!--  -->
<!-- invisible(gc()) -->
<!-- ``` -->
<!--  -->
<!-- ### Compute UMAP dimension reduction of the integrated object based on the random initial coordinates -->
<!--  -->
<!-- ```{r apply_UMAPshared} -->
<!-- cells.use <- colnames(SO.align) #WhichCells(object = tmp,downsample = 300) #colnames(SO) #sample(colnames(SO),1000) -->
<!-- Idents(SO.align) <- SO.align$model -->
<!-- local_connectivity=1 # Should not be more than the local intrinsic dimension of the manifold. I would have imagined 2-3 could be reasonable, but doesn't give good results.  -->
<!-- fast_sgd <- TRUE # Should set it to false ultimately, to get exactly reproducible results, but can use T to get faster for early exploration.  -->
<!-- reduction.use <- "pca" -->
<!--  -->
<!--  -->
<!-- umap_init <- as.matrix(x_ini[cells.use,]) # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates.  -->
<!--  -->
<!-- set.seed(general.seed) -->
<!-- tmp <- umap(X = Embeddings(SO.align[[reduction.use]])[cells.use, 1:top.pcs], -->
<!--             init = umap_init, -->
<!--             n_neighbors = nn, -->
<!--             n_components = 3, -->
<!--             metric = "cosine", -->
<!--             min_dist = min_dist, -->
<!--             spread = spread, -->
<!--             init_sdev = 1e-4, -->
<!--             local_connectivity = local_connectivity, -->
<!--             ret_model=T,  -->
<!--             verbose = F) -->
<!-- tmp2 <- 0*Embeddings(SO.align[[reduction.use]])[,1:3] -->
<!-- tmp2[cells.use,] <- tmp$embedding -->
<!-- SO.align[["umapShared3d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAPshared3d_", assay = DefaultAssay(SO.align)) -->
<!--  -->
<!-- coordinates3D <- as.data.frame(Embeddings(SO.align[, WhichCells(SO.align, ident = "Gastruloids")], reduction = "umapShared3d")) -->
<!-- write.table(x = coordinates3D, file = file.path(dataset.anFolder, -->
<!--                                                paste0("init_umap3Dcoordinates_",  -->
<!--                                                       dataset, "_", combine.meth, ".csv")), sep = ",", row.names = TRUE, col.names = TRUE) -->
<!--  -->
<!--  -->
<!-- umap_init <- as.matrix(x_ini[cells.use, 1:2]) # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates.  -->
<!--  -->
<!-- set.seed(general.seed) -->
<!-- tmp <- umap(X = Embeddings(SO.align[[reduction.use]])[cells.use, 1:top.pcs], -->
<!--             init = umap_init, -->
<!--             n_neighbors = nn, -->
<!--             n_components = 2, -->
<!--             metric = "cosine", -->
<!--             min_dist = min_dist, -->
<!--             spread = spread, -->
<!--             init_sdev = 1e-4, -->
<!--             local_connectivity = local_connectivity, -->
<!--             ret_model=T,  -->
<!--             verbose = F) -->
<!-- tmp2 <- 0 * Embeddings(SO.align[[reduction.use]])[, 1:2] -->
<!-- tmp2[cells.use, ] <- tmp$embedding -->
<!-- SO.align[["umapShared2d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAPshared2d_", assay = DefaultAssay(SO.align)) -->
<!--  -->
<!-- coordinates2D <- as.data.frame(Embeddings(SO.align[, WhichCells(SO.align, ident = "Gastruloids")], reduction = "umapShared2d")) -->
<!-- write.table(x = coordinates2D, file = file.path(dataset.anFolder, -->
<!--                                                paste0("init_umap2Dcoordinates_",  -->
<!--                                                       dataset, "_", combine.meth, ".csv")), sep = ",", row.names = TRUE, col.names = TRUE) -->
<!--  -->
<!-- rm(tmp, tmp2, cells.use, x_ref, x_ini) -->
<!-- invisible(gc()) -->
<!-- ``` -->
<!--  -->
<!-- # Compute UMAP dimension reduction of the `r dataset` dataset initilized with the coordinates obtained through the atlas integration {.tabset .tabset-pills .tabset-fade} -->
<!--  -->
<!-- ```{r UMAP-dataset, out.width="50%"} -->
<!-- # Create 3-dimensional UMAP coordinates -->
<!-- init_sdev <- 1e-4 -->
<!-- noise_level <- 0 -->
<!-- min_dist <- 6 -->
<!-- spread <- 15 -->
<!-- nn <- 300 -->
<!--  -->
<!-- umap_init <- as.matrix(coordinates3D) -->
<!-- set.seed(general.seed) -->
<!-- umap_init <- umap_init + cbind(rnorm(nrow(umap_init),sd = noise_level), -->
<!--                                rnorm(nrow(umap_init),sd = noise_level), -->
<!--                                rnorm(nrow(umap_init),sd = noise_level)) -->
<!-- set.seed(general.seed) -->
<!-- reduction.use <- "pca" # pca1 or harmony -->
<!-- tmp <- umap(X = Embeddings(SO[[reduction.use]])[colnames(SO), 1:top.pcs], -->
<!--             init = umap_init, -->
<!--             n_neighbors = nn, -->
<!--             n_components = 3, -->
<!--             metric = "cosine", -->
<!--             min_dist = min_dist, -->
<!--             spread = spread, -->
<!--             local_connectivity=1, -->
<!--             ret_model=T, -->
<!--             verbose = F, -->
<!--             n_epochs = 1000, -->
<!--             learning_rate = 1, -->
<!--             init_sdev = init_sdev) -->
<!--  -->
<!-- tmp2 <- 0*Embeddings(SO[["pca"]])[,1:3] -->
<!-- tmp2[colnames(SO),] <- tmp$embedding -->
<!-- SO[["umap3d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP3d_", assay = DefaultAssay(SO)) -->
<!--  -->
<!-- coordinates3D_final <- as.data.frame(Embeddings(SO, reduction = "umap3d")) -->
<!-- write.table(x = coordinates3D_final, file = file.path(dataset.anFolder, -->
<!--                                                paste0("final_umap3Dcoordinates_",  -->
<!--                                                       dataset, "_", combine.meth, ".csv")), sep = ",", row.names = TRUE, col.names = TRUE) -->
<!--  -->
<!-- # Create 2-dimensional UMAP coordinates -->
<!-- umap_init <- as.matrix(coordinates2D) -->
<!-- set.seed(general.seed) -->
<!-- umap_init <- umap_init + cbind(rnorm(nrow(umap_init),sd = noise_level), -->
<!--                                rnorm(nrow(umap_init),sd = noise_level)) -->
<!-- set.seed(general.seed) -->
<!-- reduction.use <- "pca" # pca1 or harmony -->
<!-- tmp <- umap(X = Embeddings(SO[[reduction.use]])[colnames(SO), 1:top.pcs], -->
<!--             init = umap_init, -->
<!--             n_neighbors = nn, -->
<!--             n_components = 2, -->
<!--             metric = "cosine", -->
<!--             min_dist = min_dist, -->
<!--             spread = spread, -->
<!--             local_connectivity=1, -->
<!--             ret_model=T, -->
<!--             verbose = F, -->
<!--             n_epochs = 1000, -->
<!--             learning_rate = 1, -->
<!--             init_sdev = init_sdev) -->
<!--  -->
<!-- tmp2 <- 0*Embeddings(SO[["pca"]])[,1:2] -->
<!-- tmp2[colnames(SO),] <- tmp$embedding -->
<!-- SO[["umap2d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP2d_", assay = DefaultAssay(SO)) -->
<!--  -->
<!-- coordinates2D_final <- as.data.frame(Embeddings(SO, reduction = "umap2d")) -->
<!-- write.table(x = coordinates2D_final, file = file.path(dataset.anFolder, -->
<!--                                                paste0("final_umap2Dcoordinates_",  -->
<!--                                                       dataset, "_", combine.meth, ".csv")), sep = ",", row.names = TRUE, col.names = TRUE) -->
<!-- ``` -->

## Dimplot of the predicted celltypes

```{r, out.width="50%"}
# Plot the celltypes on the umap2d embedding
Idents(SO) <- SO@meta.data$celltype
DimPlot(SO,
        reduction = "umap",
        pt.size = 1,
        repel = TRUE,
        label = TRUE,
        label.size = 6,
        cols = colors.celltype[levels(Idents(SO))]) +
  ggtitle(paste0(dataset, " : cell identities")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        axis.title = element_blank(),
        line = element_blank()) +
        NoLegend()
```

## Facets of the predicted celltypes

```{r plot-celltype-facets2, fig.height = 20}
cellsData <- data.frame(SO@reductions[["umap"]]@cell.embeddings, SO@meta.data$celltype)
colnames(cellsData) <- c(colnames(SO@reductions[["umap"]]@cell.embeddings), "celltype")

ggplot(cellsData[c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP_1,
              y = UMAP_2)) +
    geom_point( alpha = .4,
                size  = .75,
                color = "grey") +
    geom_point( data = cellsData, # Now provide data including column for facetting
                aes(color = celltype),
                alpha = .5,
                size  = 1.2) +
    scale_fill_manual(values = colors.celltype[SO@meta.data$celltype], aesthetics = "color") +
    facet_wrap(facets = vars(celltype),
               ncol = 3) +
    NoLegend() +
    ggtitle(paste0(dataset, " : cell identity facets")) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          axis.title = element_blank(),
          line = element_blank())

rm(umap_init, tmp, tmp2)
invisible(gc())
```

```{r setup13, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart7, results='asis'}
SO <- readRDS(file.path(rdsObjects, paste0("07_clusters_", dataset, ".rds")))
resolutions <- c(seq(0.1, 0.4, 0.1), seq(0.6, 1.6, 0.2))
invisible(sapply(resolutions, function(ares)
{
    cat("### Res.  ", ares, "\n")
    
    clusterResName <- grep(paste0(DefaultAssay(SO), "_snn_res.", ares, "$"), colnames(SO@meta.data), value = TRUE)
    Idents(SO) <- clusterResName
    clustersColor <- setNames(hue_pal()(length(levels(SO@meta.data[,clusterResName]))), levels(SO@meta.data[,clusterResName]))
    
    print(DimPlot(SO,
                   reduction = "umap",
                   pt.size = 1,
                   label = TRUE,
                   label.size = 6,
        repel = TRUE,
        cols = clustersColor[levels(Idents(SO))]) +
               NoLegend() +
               ggtitle(paste0(dataset, " : clusters at resolution ", ares)) +
               theme(plot.title = element_text(hjust = 0.5),
                     axis.text = element_blank(),
                     line = element_blank())
    )
    cat(" \n \n") # Required for '.tabset'
}))
```

```{r setup16, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

# Differential expression analysis

```{r selected-resolution}
#SO$seurat_clusters <- NULL
selectedRes <- grep(paste0(DefaultAssay(SO), ".*res.", res, "$"), colnames(SO@meta.data), value=TRUE)
SO$clusters <- SO[[selectedRes]]
Idents(SO) <- SO$clusters

DefaultAssay(SO) <- 'RNA'

markers <- FindAllMarkers(SO, only.pos = TRUE)
#markers.sign <- markers[markers$p_val_adj < 0.001 & markers$avg_logFC > log(1.5), ]
markers.sign <- markers[order(-markers$avg_log2FC), ]
markers.sign <- markers.sign[order(markers.sign$cluster), ]
markers.sign <- markers.sign[ , c(6, 7, 2:4, 1, 5)]
write.table(x = markers.sign, file = file.path(dataset.anFolder,
						paste0("markers_min.pct_logFC_default_", 
                                            dataset, "_integ.res_", selectedRes, "_", combine.meth, ".csv")), sep = ",", row.names = F, col.names = T)

topNmarkers <- extract_topn(markers.sign, topn = top.markers)

dominantCelltypes <- add_dominantMetadata(SO, metadata = "celltype")
topNmarkers <- left_join(topNmarkers, dominantCelltypes, by='cluster')
dominantDays <- add_dominantMetadata(SO, metadata = "day")
topNmarkers <- left_join(topNmarkers, dominantDays, by='cluster')

write.table(x = topNmarkers, file = file.path(dataset.anFolder, paste0("top_", top.markers, "_markers_", dataset, "_", combine.meth, ".csv")), sep = ",", row.names = F, col.names = T)

datatable(topNmarkers, rownames = FALSE, filter = "top", options = list(pageLength = 5, scrollX=T))
```

```{r setup17, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart8}
celltypes <- read.table(
    file = file.path(dataset.anFolder, paste0("cellIdentitiesPredictions_multiTP_", dataset, "_", combine.meth, ".csv")),
    sep = ",",
    header = TRUE)
umap <- read.table(
    file = file.path(dataset.anFolder, paste0("final_umap2Dcoordinates_", dataset, "_", combine.meth, ".csv")),
    sep = ",",
    header = TRUE)
topNmarkers <- read.table(file.path(dataset.anFolder, paste0("top_", top.markers, "_markers.csv")), sep = ",", header = T)
datatable(topNmarkers, rownames = FALSE, filter = "top", options = list(pageLength = 5, scrollX=T))
SO <- readRDS(file.path(rdsObjects, paste0("05_preprocessing_", dataset, "_", combine.meth, ".rds")))
SO[["umap"]] <- CreateDimReducObject(embeddings = as.matrix(umap), key = "UMAP_")
SO <- AddMetaData(SO, metadata = celltypes$predicted.id, col.name = "celltype")
selectedRes <- grep(paste0(DefaultAssay(SO), ".*res.", res, "$"), colnames(SO@meta.data), value=TRUE)
markers.sign <- read.table(file.path(dataset.anFolder, paste0("markers_min.pct_logFC_default_", dataset, ".integ.res_", selectedRes, ".csv")), sep = ",", header = T)
topNmarkers <- read.table(file.path(dataset.anFolder, paste0("top_", top.markers, "_markers.csv")), sep = ",", header = T)
datatable(topNmarkers, rownames = FALSE, filter = "top", options = list(pageLength = 5, scrollX=T))
```

```{r setup18, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
  eval = TRUE,
  echo = TRUE
)
```

# Additional Plots

```{r addPlots-1}
# Load list of genes of interest
goi <- read.table(file.path(otherInputs, "genes_of_interest3-scRNAseq.tsv"), sep = ",")
goiList <- goi$V1

# Parameters
ntop <- 5


DefaultAssay(SO) <- "RNA"
topNmarkers <- extract_topn(markers.sign, topn = ntop)
topNgenes <- unique(topNmarkers$gene)


genesToRemove <- goiList[!(goiList %in% rownames(SO))]
if (length(genesToRemove) >= 1){
  cat(paste0("One or more genes of interest are not in the dataset (maybe because of the case):\n\t",
                 str_c(genesToRemove, collapse = ", "), "\nThe listed genes are to be removed of the plots"))
}
goiList <- goiList[goiList %in% rownames(SO)] # remove the unknown genes
```

## Cluster identity {.tabset .tabset-pills .tabset-fade}

```{r addPlots-3}
clusterResName <- grep(paste0(DefaultAssay(SO), "_snn_res.", res, "$"), colnames(SO@meta.data), value = TRUE)
Idents(SO) <- clusterResName
```

### DimPlot of the cluster identity

```{r cluster-dimplot, out.width='50%'}
clustersColor <- setNames(hue_pal()(length(levels(SO@meta.data[,clusterResName]))), levels(SO@meta.data[,clusterResName]))

DimPlot(SO,
        reduction = "umap",
        pt.size = 1,
        label = TRUE,
        label.size = 6,
        repel = TRUE,
        cols = clustersColor[levels(Idents(SO))]) +
    theme_void() +
    ggtitle(paste0(dataset, " : clusters at resolution ", res)) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank()) +
    NoLegend()
```

### DotPlot of the markers on cluster identity

```{r cluster-dotPlot-markers}
## DotPlot the n-top markers of each cluster
dotPlotsMarkers(SO, topNgenes, title=paste0("Top ", ntop, " markers of each cluster in clusters"))
```

### DotPlot of the genes of interest on cluster identity

```{r cluster-dotPlot-goi}
## DotPlot the genes of interest
dotPlotsGoi(SO, goiList, title="Genes of interest in clusters")
```

### FeaturePlots of the markers {.tabset .tabset-pills .tabset-fade}

```{r featurePlots-markers, results='asis', out.width='20%', fig.align='default'}
# code with the courtesy of Lionel Spinelli and Romain Fenouil
topMarkers = by( markers.sign, markers.sign[["cluster"]], function(x)
{
  # Filter markers based on adjusted PValue
  x = x[ x[["p_val_adj"]] < 0.005, , drop = FALSE]
  # Sort by decreasing logFC
  x = x[ order(abs(x[["avg_log2FC"]]), decreasing = TRUE), , drop = FALSE ]
  # Return top ones
  return( if(is.null(  top.markers )) head( x, n =  10 ) else head( x, n =  min(top.markers, 10) ))
})

clustersColor <- setNames(hue_pal()(length(names(topMarkers))), names(topMarkers))

invisible( lapply( names( topMarkers), function(clusterName)
{
  cat("#### Cl. <span style='border-radius: 3px border: 3px solid ", clustersColor[clusterName], " padding:0px 2px'>", clusterName, "</span>\n")
  
  # Highlight cells of current cluster on a dimreduc plot
  highlightClusterPlot(clusterName, seuratObject = SO, reduction = ifelse( exists("useReduction"), useReduction, "umap"))
  
  # Plots expression on projected cells
  invisible( lapply( topMarkers[[clusterName]][["gene"]], function(featureName)
  {
    print( FeaturePlot( SO, features = featureName, reduction = ifelse( exists("useReduction"), useReduction, "umap"), order = TRUE) +
             theme( axis.title.x = element_blank(),
                    axis.title.y = element_blank(),
                    legend.position = "none"))
  }))
  
  cat(" \n \n") # Required for '.tabset'
}))
```

### FeaturePlots of the genes of interest with cluster labels

```{r cluster-featurePlot-goi}
## FeaturePlot the genes of interest
# doFeaturePlot(SO, goiList[10:12]) # single plot on all the data
doFeaturePlot(SO, goiList, split.by="day") # complete data + splitted by day
```

### ViolinPlots of the markers {.tabset .tabset-pills .tabset-fade}

```{r violinPlots-markers, results='asis', out.width='20%', fig.align='default'}
# with courtesy of Lionel Spinelli and Romain Fenouil
invisible( lapply( names( topMarkers), function(clusterName)
{
  cat("#### Cl. <span style='border-radius: 3px border: 3px solid ", clustersColor[clusterName], " padding:0px 2px'>", clusterName, "</span>\n")
  
  # Remind cluster name in an empty figure to keep consistent alignment of panels between tabs
  plot( c( 0, 1), c( 0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n')
  text( x = 0.5, y = 0.5, paste( "Cluster", clusterName), cex = 2, col = clustersColor[clusterName])
  
  # Violinplot for expression value of marker genes by cluster (+ number of 'zero' and 'not zero' cells)
  invisible( lapply( topMarkers[[clusterName]][["gene"]], violinFeatureByCluster, seuratObject = SO, clustersColor = clustersColor))
  
  cat(" \n \n") # Required for '.tabset'
}))
```

## Celltype identity {.tabset .tabset-pills .tabset-fade}

```{r addPlots-4}
Idents(SO) <- factor(SO@meta.data$celltype, levels = sort(levels(as.factor(SO@meta.data$celltype))))
```

### DimPlot of the celltype identity {.tabset .tabset-pills .tabset-fade}

```{r celltype-dimplot, results='asis', out.width="50%"}
## DimPlot the celltype
DimPlot(SO,
        reduction = "umap",
        pt.size = 1,
        repel = TRUE,
        label = TRUE,
        label.size = 6,
        cols = colors.celltype[levels(Idents(SO))]) +
    theme_void() +
  ggtitle(paste0(dataset, " : cell identities")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        line = element_blank()) +
  NoLegend()

cellsData <- data.frame(SO@reductions[["umap"]]@cell.embeddings, SO@meta.data$celltype)
colnames(cellsData) <- c(colnames(SO@reductions[["umap"]]@cell.embeddings), "celltype")

invisible(sapply(levels(as.factor(SO@meta.data$celltype)), function(act)
{
    cat("#### ", act, "\n")
        
    print(ggplot(cellsData[c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets
         aes( x = UMAP_1,
              y = UMAP_2)) +
    geom_point( alpha = .4,
                size  = 1,
                color = "grey") +
    geom_point( data = cellsData[cellsData$celltype == act,], # Now provide data including column for facetting
                aes(color = celltype),
                alpha = .5,
                size  = 3.5) +
    theme_void() +
    scale_fill_manual(values = colors.celltype[SO@meta.data$celltype], aesthetics = "color") +
    NoLegend() +
    ggtitle(paste0(act)) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank())
    )

    cat(" \n \n") # Required for '.tabset'
}))
```

### DotPlot of the markers on celltype identity

```{r celltype-dotPlot-markers}
## DotPlot the n-top markers of each celltype
dotPlotsMarkers(SO, topNgenes, title=paste0("Top ", ntop, " markers of each cluster in celltypes"))
```

### DotPlot of the genes of interest on celltype identity

```{r celltype-dotPlot-goi}
## DotPlot the genes of interest
dotPlotsGoi(SO, goiList, title="Genes of interest in celltypes")
```

<!-- ### Celltype annotation concistency -->
<!--  -->
<!-- ```{r celltype-heatmap-concistency} -->
<!-- # Celltype annotation moves -->
<!-- createHeatmapAnn(SO, day = NULL) + -->
<!--         ggtitle(paste0(dataset, "\nTransfer label consistency between single TP and integrated TP label transfer")) + -->
<!--         CenterTitle() + -->
<!--         labs(x = "Celltype annotation on the single datasets", y = paste0("Celltype annotation on the ", length(sep_days), "integrated datasets")) -->
<!--  -->
<!-- invisible(sapply(levels(as.factor(SO@meta.data$day)), function(x) { -->
<!--     print(reateHeatmapAnn(SO, day=x) + -->
<!--         ggtitle(paste0(x, "\nTransfer label consistency between single TP and integrated TP label transfer")) + -->
<!--         CenterTitle() + -->
<!--         labs(x = paste0("Celltype annotation on the single ", x, " dataset"), y = paste0("Celltype annotation on the ", SO@project.name, " dataset")) -->
<!--     ) -->
<!-- })) -->
<!-- ``` -->

## Day identity {.tabset .tabset-pills .tabset-fade}

```{r addPlots-5}
# Day identity
Idents(SO) <- factor(SO@meta.data$day, levels = sort(levels(as.factor(SO@meta.data$day)), decreasing = T))
```

### DimPlot of the day identity

```{r day-dimplot, out.width="50%", fig.show='hold'}
## DimPlot the days
DimPlot(SO, reduction = "umap",
        pt.size = 1,
        repel = TRUE,
        label = TRUE,
        label.size = 6,
        cols = colors.stage[levels(Idents(SO))]) +
  ggtitle(paste0("Days\n", dataset)) +
  CenterTitle() +
  NoAxes() +
  NoLegend()


cellsData <- data.frame(SO@reductions[["umap"]]@cell.embeddings, SO@meta.data$day)
colnames(cellsData) <- c(colnames(SO@reductions[["umap"]]@cell.embeddings), "day")
    
ggplot(cellsData[c('UMAP_1', 'UMAP_2')], # Omit the column used for facetting to get all points repeated in all facets
     aes( x = UMAP_1,
          y = UMAP_2)) +
    geom_point( alpha = .4,
                size  = 1,
                color = "grey") +
    geom_point( data = cellsData, # Now provide data including column for facetting
                aes(color = day),
                alpha = .5,
                size  = 3.5) +
    theme_void() +
    scale_fill_manual(values = colors.stage[SO@meta.data$day], aesthetics = "color") +
    facet_wrap(facets = vars(day),
               ncol = 2) +
    NoLegend() +
    ggtitle(paste0(dataset, "\nFacet on the day of the dataset")) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          line = element_blank())
```

### RidgePlot of the markers on time point identity (day)

```{r day-ridgePlot-marker, out.width='20%', fig.align='default'}
## RidgePlot on markers
#createRidgePlot(SO, topNgenes)
invisible(sapply(topNgenes, function(marker){
    print(RidgePlot(SO, features = marker, cols=alpha(colors.stage, 0.66)))
}))
```

### RidgePlot of the genes of interest on time point identity (day)

```{r day-ridgePlot-goi, out.width='20%', fig.align='default'}
#createRidgePlot(SO, goiList)
invisible(sapply(goiList, function(marker){
    print(RidgePlot(SO, features = marker, cols=alpha(colors.stage, 0.66)))
}))
```

