---
author: "Céline Chevalier, Anaïs Baudot, Fabienne Lescroart, Laurent Argiro, Stéphane Zaffran"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output:
    html_document:
        theme:
            bootswatch: yeti
        toc: yes
        toc_float:
          collapsed: false
          smooth_scroll: true
        number_sections: yes
        df_print: kable
        code_folding: hide
    pdf_document:
        number_sections: yes
        toc: yes
        toc_depth: 3
        keep_tex: no
params:
    analysis.name:
        value: "analysis_"
    new.analysis:
        value: FALSE
    dataset:
        value: NA
        choices: [lab_day_04, lab_day_05, lab_day_05bis, lab_day_06, lab_day_11]
    do.integ:
        value: FALSE
    do.merge:
        value: FALSE
    mito.low:
        value: 1.5
        min: 0
        max: 99
    mito.high:
        value: 10
        min: 1
        max: 100
    ribo.low:
        value: 25
        min: 0
        max: 99
    ribo.high:
        value: 45
        min: 1
        max: 100
    min.feat:
        value: 200
    min.cells:
        value: 3
    min.counts:
        value: 1500
    max.counts:
        value: 150000
    norm.meth:
        value: "LogNormalize"
    hvg.meth:
        value: mvp
        choices: [vst, mvp, disp]
    hvg.num:
        value: FALSE
    do.scale:
        value: FALSE
    pca.npcs:
        value: 30
    pca.print:
        value: 10
    top.pcs:
        value: 15
    dblt.rate:
        value: 8
    res:
        value: 1.0
    algo.cluster:
        value: 4
        choices: [1, 2, 3, 4]
    top.markers:
        value: 20
    general.seed: 17
title: |
  | Protocole 1:
  | single scRNAseq data analysis
  | `r params$dataset`
---

<!-- Javascript for zooming on figures (adapted from: https://stackoverflow.com/questions/40401680) -->

<!-- Jquery import conflicts with DT::datatable so needs to be commented here -->
<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script> -->

<style>
.zoomDiv {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  z-index: 50;
  transform: translate(-50%, -50%);
  background-color: #FFFFFF;
  box-shadow: 0px 0px 50px #888888;
  width: fit-content;
  max-width: 90%;
  max-height: 90%;
  overflow: auto;
}

.zoomImg {
  width: 100%;
}
</style>

<script type="text/javascript">
  $(document).ready(function() {
    $('body').prepend("<div class=\"zoomDiv\"><img src=\"\" class=\"zoomImg\"></div>");
    // onClick for all img except the zoomed one and link ones (filter)
    // use 'img.zoom' and out.extra='class=\"zoom\"' in chunk to specify manually which chunk images can be zoomed
    $('img:not(.zoomImg)').filter(':not(a *)').click(function() {
      $('.zoomImg').attr('src', $(this).attr('src'));
      $('.zoomDiv').show();
    });
    // onClick function for hiding div
    $('img.zoomImg').click(function() {
      $('.zoomDiv').hide();
    });
  });
</script>



```{r setup1, eval=TRUE, include=FALSE}
options(knitr.purl.inline = TRUE)
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  
  # text output
  echo = TRUE,
  results = 'hold',
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  strip.white = TRUE,
  
  # code decoration
  #tidy = TRUE,
  tidy.opts = list(width.cutoff = 90),
  comment = '',
  attr.output='.numberLines',
  
  # plots
  #fig.path = "figure/",      # is set later, in chunk setup2
  fig.show = "asis",         # tuned to "hold" in multiple plots chunk
  dev = c('png', 'pdf'),
  fig.width = 12,
  fig.height = 12,
  #fig.asp=1.3               # fig.height = fig.width * fig.asp
  #out.extra = 'style="border:5px solid orange;"'     # orange box arround plots
  fig.align = "center"       # should be tuned to default in multiple plots chunk
)
```

```{r load-lib, include=FALSE}
library(dplyr)
library(Matrix)
library(Seurat)
library(ggplot2)
library(reticulate)
library(scmap)
library(RColorBrewer)
library(DoubletFinder)
library(stringr)
library(kableExtra)
library(formattable)
library(knitr)
library(SingleCellExperiment)
library(BiocGenerics)
library(scales)
library(formatR)
library(uwot)
library(DT)
library(patchwork)
```

```{r get-params, include=FALSE}
bindingIsLocked("params", env = .GlobalEnv)
unlockBinding("params", env = .GlobalEnv)
attach(params)
```

```{r sourceCodes}
#source("./utilities/dimplotMetadata.R")
source("./utilities/extract_topn.R")
source("./utilities/add_dominantMetadata.R")
source("./utilities/additionalPlots.R")
source("./utilities/00_generalDeps.R")
```


# Global settings {.tabset .tabset-pills .tabset-fade}

## `r dataset` analysis settings

```{r show-params}
ul <- unlist(params)
df <- data.frame(keyName=names(ul), value=ul, row.names=NULL)
names(df) <- c('Parameters', 'Values')
df1 <- df[1:ceiling(dim(df)[1]/3),]
df1$Parameters <- cell_spec(df1$Parameters, bold = T)
df2 <- df[(ceiling(dim(df)[1]/3)+1):(2*ceiling(dim(df)[1]/3)),]
df2$Parameters <- cell_spec(df2$Parameters, bold = T)
df3 <- df[((2*ceiling(dim(df)[1]/3))+1):dim(df)[1],]
df3$Parameters <- cell_spec(df3$Parameters, bold = T)


list(df1, df2, df3) %>%
  knitr::kable(align = "ll", row.names = FALSE, escape = F) %>% 
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE)
rm(df)
```


## Directories

Set either input and output directories.

```{r base-path}
#basePath <- "/home/celine/temp2"
basePath <- "/mnt/DATA_4TB/projects/gastruloids_sc_Lescroart/analysis/seuratAnalysis" # local server
#basePath <- "/shared/projects/mothard_in_silico_modeling/seurat_analysis" # IFB server
```

### Input directories

Get the path of the inputs used for the analysis:

- mmgLab.data

- atlas.folder

- classifier.folder

- inputTables.folder

- otherInputs

```{r input-dirs}
inputs.folder <- file.path(basePath, "inputData")

mmgLab.data <- file.path(inputs.folder, "lab_data")
atlas.folder <- file.path(inputs.folder, "atlas")
classifier.folder <- file.path(inputs.folder, "scmap_pijuansala_classifier")
inputTables.folder <- file.path(inputs.folder, "InputTables")
otherInputs <- file.path(inputs.folder, "other")
```

### Output directories

Management of pre-existing ran analysis to output figures, tables and reports.

```{r anteriority, eval=!new.analysis, echo=!new.analysis}
last_analysis <- 0
dirs.in.dir <- list.dirs(basePath, full.names = FALSE, recursive = FALSE)
anterior <- analysis.name %in% dirs.in.dir
if (anterior){
  last_analysis <- max(as.numeric(str_extract_all(anterior, "\\d+", simplify = TRUE)), na.rm=T)
} else {
  params$new.analysis <- TRUE
  attach(params)
}
```

```{r default_analysisName_old, eval=(!new.analysis && analysis.name == "analysis_"), echo=(!new.analysis && analysis.name == "analysis_")}
analysis.name <- paste0(analysis.name, as.character(last_analysis))
```

```{r default_analysisName_new, eval=(new.analysis && analysis.name == "analysis_"), echo=(new.analysis && analysis.name == "analysis_")}
analysis.name <- paste0(analysis.name, as.character(last_analysis + 1))
```

```{r newAnalysis, eval=new.analysis, echo=new.analysis}
baseAnalysis <- file.path(basePath, analysis.name)
if(!dir.exists(baseAnalysis)){dir.create(baseAnalysis)}
rdsObjects <- file.path(baseAnalysis, "rdsObjects")
if(!dir.exists(rdsObjects)){dir.create(rdsObjects)}
print(baseAnalysis)
```

```{r reAnalysis, eval=!new.analysis, echo=!new.analysis}
baseAnalysis <- file.path(basePath, analysis.name)
rdsObjects <- file.path(baseAnalysis, "rdsObjects")
if(!dir.exists(rdsObjects)){dir.create(rdsObjects)}
```

```{r dataset-analysisFolder}
dataset.anFolder <- file.path(baseAnalysis, dataset)
if(!dir.exists(dataset.anFolder)){dir.create(dataset.anFolder)}
fig.folder <- file.path(dataset.anFolder, "figures/")
if(!dir.exists(fig.folder)){dir.create(fig.folder)}
```

```{r setup2, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  
  # figures
  fig.path = fig.folder
)
```

## Set up color vectors

Load table to in which colors are defined for the labels used in the analysis.

```{r load_colorTables}
colors.table <- read.table(file=file.path(inputTables.folder, "ClusterColors.tsv"), sep="\t", header=T, comment.char="", as.is=T)
colors.celltype <- setNames(colors.table$blind_friendly[!is.na(colors.table$transferred_identity)], colors.table$transferred_identity[!is.na(colors.table$transferred_identity)])

colors.stage <- setNames(c("#bb573b", "#ac9d3e", "#5aaf6a", "#7564b9", "#b94c84", "#ba4b7d", "#90b03d", "#60a756", "#45c097", "#5e8bd5", "#6d71d8", "#573585", "#bd80d5", "#b853a2", "#ba4b7d"), c("Day_04", "Day_05", "Day_06", "Day_07", "Day_10", "Day_11", "E6.5", "E6.75", "E7.0", "E7.25", "E7.5", "E7.75", "E8.0", "E8.25", "E8.5"))
```

```{r starter, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  echo = TRUE
)
```

# Get `r dataset` data

## Load the data

```{r single-load}
data.path <- file.path(mmgLab.data, dataset)
raw.data <- Read10X(data.dir = data.path, gene = 2)
SO <- CreateSeuratObject(counts=raw.data, project=dataset)
```

## Add and show metadata

```{r add-metaData}
day <- str_to_title(str_extract(dataset, 'day_[0-9]*$'))

SO <- AddMetaData(object = SO, metadata = day, col.name = "day")
SO <- AddMetaData(object = SO, metadata = dataset, col.name = "dataset")
replicateValue <- if (dataset == "lab_day_05bis") 1 else 0
SO <- AddMetaData(SO, metadata = replicateValue, col.name = 'replicate')
SO$model <- "Gastruloids"
```

```{r show-metaData}
data.frame(head(SO@meta.data)) %>%
  knitr::kable(align = "lrrrrrr",
               caption = paste0("6 first lines of the ", dataset, " metadata table")) %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")
```

## Nomenclature for cell names

```{r renaming_cells}
cell_ids <- colnames(SO)
UMIs <- str_extract(cell_ids, '[A-Z]*')
cellnames <- paste(SO$dataset, SO$replicate, UMIs, sep = '_')

SO <- RenameCells(SO, new.names = cellnames)

head(colnames(SO), 4)
```

Below, we can see that there are as many unique cell identifiers as the number of cells.

Number of cells in the dataset: `r dim(SO)[2]`

Number of unique cell identifiers: `r length(unique(colnames(SO)))`


- - -

\clearpage

```{r initial-size, echo=FALSE}
size_track1 <- data.frame(cbind(
  t(dim(SO)),
  "Preliminary Counts",
  "01"
))

colnames(size_track1) <- c('Nbr_of_features', 'Nbr_of_cells', 'Analysis_step_name', 'Step_number')
```

# Quality control

## Percentage of mitochondrial reads & threshold

```{r addMitoPercentage, fig.align='default', out.width='35%', fig.show='hold'}
SO[["percent.mito"]] <- PercentageFeatureSet(SO, pattern="^mt-")      # CHANGE THE PATTERN TO FIT ANY SPECIES
SO@meta.data[SO@meta.data$percent.mito > mito.high, "outlier.mito"] <- TRUE
SO@meta.data[SO@meta.data$percent.mito < mito.high, "outlier.mito"] <- FALSE

plot1 <- VlnPlot(SO, features = c("percent.mito")) +
    geom_hline(aes(yintercept = mito.high), color = "#FF0000AA", size = 1.5) +
    ggtitle("Mitochondrial expression\npercentage", subtitle = paste0("threshold at ", mito.high, "%")) +
    theme(axis.title.x = element_blank(),
          axis.text = element_text(size = 16),
          axis.text.x = element_text(angle = 0, size = 24, hjust = 0.5, face = "bold"),
          text = element_text(size = 24),
          plot.subtitle = element_text(hjust = 0.5)) +
    NoLegend() +
    scale_y_continuous(labels = scales::percent_format(scale = 1))

plot2 <- VlnPlot(SO, features = c("percent.mito")) +
    geom_hline(aes(yintercept = mito.high), color = "#FF0000AA", size = 1.5) +
    ggtitle("Zoom in", subtitle = paste0("threshold at ", mito.high, "%")) +
    theme(axis.title.x = element_blank(),
          axis.text = element_text(size = 16),
          axis.text.x = element_text(angle = 0, size = 24, hjust = 0.5, face = "bold"),
          text = element_text(size = 24),
          plot.subtitle = element_text(hjust = 0.5)) +
    NoLegend() +
    scale_y_continuous(labels = scales::percent_format(scale = 1)) +
    coord_cartesian(ylim = c(0, 12))

plot1
plot2
```

The number of cells removed by this filter is `r table(SO$outlier.mito)["TRUE"]`.
These cells have a percentage of mitochondrial reads higher than the threshold of `r mito.high`%.


## Percentage of ribosomal reads & threshold

```{r addRiboPercentage, fig.align = "center", out.width='35%'}
SO[["percent.ribo"]] <- PercentageFeatureSet(SO, pattern="^Rp[sl]")   # SEE IF ANY MODIFICATION IS REQUIRED
SO@meta.data[SO@meta.data$percent.ribo > ribo.low, "outlier.ribo"] <- FALSE
SO@meta.data[SO@meta.data$percent.ribo < ribo.low, "outlier.ribo"] <- TRUE

VlnPlot(SO, features = c("percent.ribo")) +
    geom_hline(aes(yintercept = ribo.low), color="#FF0000AA", size=1.5) +
    ggtitle("Ribosomal expression\npercentage", subtitle = paste0("threshold at ", ribo.low, "%")) +
    theme(axis.title.x = element_blank(),
          axis.text = element_text(size = 16),
          axis.text.x = element_text(angle = 0, size = 24, hjust = 0.5, face = "bold"),
          text = element_text(size = 24),
          plot.subtitle = element_text(hjust = 0.5)) +
    NoLegend() +
    scale_y_continuous(labels = scales::percent_format(scale = 1))
```

The number of cells removed by this filter is `r table(SO$outlier.ribo)["TRUE"]`.
These cells have a percentage of ribosomal reads lower than the threshold of `r ribo.low`%.



## UMI counts thresholds

```{r plot-countRNA, fig.align='default', out.width='35%', fig.show='hold'}
SO@meta.data[, "outlier.nCount"] <- FALSE
SO@meta.data[SO@meta.data$nCount_RNA > max.counts | SO@meta.data$nCount_RNA < min.counts, "outlier.nCount"] <- TRUE

plot1 <- VlnPlot(SO, features = c("nCount_RNA")) +
    geom_hline(aes(yintercept = max.counts), color="#FF0000AA", size=1.5) +
    geom_hline(aes(yintercept = min.counts), color="#FF0000AA", size=1.5) +
    ggtitle("UMI counts per cell", subtitle = paste0("thresholds at ", min.counts, " and ", max.counts)) +
    ylab("nCount_RNA") +
    theme(axis.title.x = element_blank(),
          axis.text = element_text(size = 16),
          axis.text.x = element_text(angle = 0, size = 24, hjust = 0.5, face = "bold"),
          text = element_text(size = 24),
          axis.title.y = element_text(size = 16),
          plot.subtitle = element_text(hjust = 0.5)) +
    NoLegend()

plot2 <- plot1 +
    ylim(0, 25000) +
    ggtitle("Zoom in", subtitle = paste0("thresholds at ", min.counts, " and ", max.counts))

plot1
plot2
```

The number of cells removed by this filter is `r table(SO$outlier.nCount)["TRUE"]`.
These cells have either less than `r min.counts` UMI counts or more than `r max.counts` UMI counts.

## Feature counts threshold

```{r plot-featureRNA, out.width='35%'}
SO@meta.data[SO@meta.data$nFeature_RNA > min.feat, "outlier.nFeature"] <- FALSE
SO@meta.data[SO@meta.data$nFeature_RNA < min.feat, "outlier.nFeature"] <- TRUE

VlnPlot(SO, features = c("nFeature_RNA")) +
    geom_hline(aes(yintercept = min.feat), color="#FF0000AA", size=1.5) +
    ggtitle("Number of detected features\nper cell", subtitle = paste0("threshold at ", min.feat, " counts")) +
    ylab("nFeature_RNA") +
    theme(axis.title.x = element_blank(),
          axis.text = element_text(size = 16),
          axis.text.x = element_text(angle = 0, size = 24, hjust = 0.5, face = "bold"),
          text = element_text(size = 24),
          axis.title.y = element_text(size = 16),
          plot.subtitle = element_text(hjust = 0.5)) +
    NoLegend()
```

The number of cells removed by this filter is `r table(SO$outlier.nFeature)["TRUE"]`.
These cells have less than `r min.feat` feature counts.


## Repartition of detected features

Features that are detected in `r min.cells` cells or fewer will be removed from the analysis.

```{r plot-geneRepartition}
# Create dataframe
df <- data.frame(rowSums(SO@assays$RNA@counts != 0))
df$features <- rownames(df)
colnames(df) <- c('Nbr_of_cells', 'features')
rownames(df) <- NULL

## Plot gene expression repartition
ggplot(df, aes(x = Nbr_of_cells)) +
  geom_histogram() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20)) +
  ylab('Number of features') +
  xlab('Number of cells') +
  scale_x_continuous(trans = "log10") +
  expand_limits(x=c(0,10500), y=c(0,2000)) +
  geom_vline(aes(xintercept = min.cells), color="green", size=1) +
  ggtitle(paste0("Repartition of detected features\n", dataset)) +
  geom_text(aes(x=min.cells,label = paste0("\n", min.cells), y=1800, hjust = 1))
```

Based on this threshold, `r length(which(df$Nbr_of_cells <= min.cells))` features
are removed for the downstream analysis.

## Quality control application

```{r plot-filtering, fig.align='default', out.width='50%', fig.show='hold'}
outliers <- grep("^outlier.", colnames(SO@meta.data), value = TRUE)
qc_param <- c("nCount_RNA", "nFeature_RNA", "percent.mito","percent.ribo")
val <- c("nCount", "nFeature", "mito", "ribo")

plotCols <- list()
for (aValue in val){
  name <- grep(aValue, qc_param, value = TRUE)
  tmp <- grep(aValue, outliers, value = TRUE)
  plotCols[[name]] <- tmp
}

invisible(apply(combn(qc_param, 2), 2, function(x){
  do.call("<-", list(x[1], SO@meta.data[,x[1]]))
  do.call("<-", list(x[2], SO@meta.data[,x[2]]))
  print(ggplot( SO@meta.data, # Plot FALSE first and TRUE after
                aes( x = SO@meta.data[,x[1]],
                     y = SO@meta.data[,x[2]],
                     color = SO@meta.data[,plotCols[[x[1]]]] | SO@meta.data[,plotCols[[x[2]]]])) +
          geom_point( size = 0.5) +
          labs( x = x[1], y = x[2], color = "Outliers") +
          scale_color_manual( values = c( "TRUE" = "#FF0000AA", "FALSE" = "#44444444")))
}))
```

The cells deleted by application of all the thresholds are `r dim(SO@meta.data[SO@meta.data$percent.mito > mito.high | SO@meta.data$percent.ribo < ribo.low | SO@meta.data$nCount_RNA < min.counts | SO@meta.data$nCount_RNA > max.counts | SO@meta.data$nFeature_RNA < min.feat,])[1]`

```{r filterQC}
SO <- subset(SO,
             features=which(df$Nbr_of_cells > min.cells),
             subset = percent.mito < mito.high & percent.ribo > ribo.low & nCount_RNA > min.counts & nCount_RNA < max.counts & nFeature_RNA > min.feat)
```

```{r size-QCfiltering}
size_track2 <- data.frame(cbind(
  t(dim(SO)),
  "QC filtering",
  "02"
))
colnames(size_track2) <- c('Nbr_of_features', 'Nbr_of_cells', 'Analysis_step_name', 'Step_number')
size_track2$Nbr_of_cells <- as.integer(as.character(size_track2$Nbr_of_cells))
size_track2$Nbr_of_features <- as.integer(as.character(size_track2$Nbr_of_features))
```

```{r plot-evolution1}
ggplot(rbind(size_track1, size_track2), aes(x = Analysis_step_name, y = Nbr_of_cells)) +
  geom_col(aes(color = Analysis_step_name, fill = Analysis_step_name), position = position_dodge(), width = 0.6) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20),
        axis.title.x = element_blank()) +
  scale_x_discrete(labels = label_wrap(6)) +
  ggtitle(paste0("Evolution of the number of cells in the dataset\n", dataset)) +
  NoLegend() +
  ylab('Number of cells')
```

```{r garbage-collec1, include = FALSE}
gc()
```

# Preprocessing workflow before doublet removal

```{r normalization1}
SO <- NormalizeData(SO, normalization.method = norm.meth, verbose=FALSE)
```

```{r show-slots, eval=FALSE, echo=FALSE}
data.frame(GetAssayData(SO, slot = "counts")[1:5,1:5]) %>%
  knitr::kable(caption = "Raw counts in 'counts' slot") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "800px", height = "300px")
data.frame(GetAssayData(SO, slot = "data")[1:5,1:5]) %>%
  knitr::kable(caption = "Normalized counts in 'data' slot") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "800px", height = "300px")
```

```{r hvg-vst1, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp"}
SO <- FindVariableFeatures(SO, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
```

```{r hvg-mvp1, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
SO <- FindVariableFeatures(SO, selection.method = hvg.meth, verbose=FALSE)
```

```{r show-HVGnum1, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
t(as.data.frame(table(SO@assays[["RNA"]]@meta.features$mvp.variable))) %>%
  knitr::kable(caption = "Number of features selected as highly variable genes (HVG)",
               row.names = FALSE,
               escape = F,
               align = "cc") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r preprocess1-1, results='hold'}
SO <- ScaleData(SO, features=rownames(SO), do.scale=TRUE, verbose=FALSE) # do.scale=TRUE to make DoubletFinder working
SO <- RunPCA(SO, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r plot-elbow1}
ElbowPlot(SO, ndims = pca.npcs) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color="purple", size=1) +
  ggtitle(paste0(SO@project.name, "\nElbowPlot"))        
```

```{r preprocess1-2}
resolutions <- seq(0.6, 1.6, 0.2)
SO <- FindNeighbors(SO, dims = 1:top.pcs, verbose=FALSE)
SO <- FindClusters(SO, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
SO <- RunUMAP(SO, dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE)
```

```{r plot-clusters-1, fig.align='default', out.width="50%", fig.show='hold'}
for (ares in resolutions){
  clusterResName <- grep(paste0("RNA_snn_res.", ares, "$"), colnames(SO@meta.data), value = TRUE)
  Idents(SO) <- clusterResName
  
  DimPlot(SO,
          pt.size = 1,
          label = T,
          label.size = 6,
          repel = T) +
    NoLegend() +
    ggtitle(paste0(dataset, " : clusters at resolution ", ares)) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          # axis.ticks = element_blank()
          line = element_blank())
  
  Sys.sleep(0.5)
}
```

```{r save1}
saveRDS(SO, file=file.path(rdsObjects, paste0("01_standardWF_", dataset, ".rds")))
```

- - -

\clearpage

```{r setup3, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart1}
SO <- readRDS(file.path(rdsObjects, paste0("01_standardWF_", dataset, ".rds")))
```

```{r setup4, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  echo = TRUE
)
```

# Doublets identification and removal

Doublets are considered as technical artifacts that have to be filtered out.
In this part, I will use the R package DoubletFinder (REFERENCE PAPIER DOUBLET FINDER).

This tool require the following steps

-   homotypic doublet proportion estimation,

-   pK parameter optimization

to be completed.

## Parameters set up

DoubletFinder relies on 3 main parameters:

-   pN, the number of artificial generated doublets - by default = 0.25

-   pK, the PC neighborhood size used to compute proportion of artificial nearest neighbors (pANN), to be determined

-   nExp, the number of predicted doublets.

### Heterotypic doublets estimation

#### Cell annotation

##### Atlas preparation

```{r atlasLoading}
atlas.metadata <- read.table(file.path(atlas.folder, "meta.tab") , sep="\t" , header=TRUE )
atlas.genes <- read.csv(file.path(atlas.folder, "genes.tsv"), sep="\t", header = FALSE, as.is = TRUE)
atlas.data <- readMM(file.path(atlas.folder, "raw_counts.mtx"))
atlas.data@Dimnames[[2]] <- atlas.metadata$cell
atlas.data@Dimnames[[1]] <- atlas.genes$V2
```

```{r garbage-collec4, include=FALSE}
rm(atlas.genes)
gc()
```

```{r atlasStandardProcess}
atlas <- CreateSeuratObject(counts = atlas.data, project = "Atlas", min.cells=min.cells, min.features = min.feat)
rm(atlas.data)
gc()

nonFiltered <- intersect(colnames(atlas), atlas.metadata$cell)
atlas.metadata <- atlas.metadata[which(atlas.metadata$cell %in% nonFiltered),]

atlas <- NormalizeData(atlas, normalization.method = norm.meth, verbose=FALSE)
atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$stage, col.name = "day")
atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$celltype, col.name = "celltype")
atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$sequencing.batch, col.name = "replicate")
#atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$sequencing.batch+10, col.name = "Replicate")
atlas <- AddMetaData(object = atlas, metadata = paste(atlas$day, "_batch_0", atlas$replicate, sep=""), col.name = "dataset")
atlas$model <- "Embryo"
```

```{r garbage-collec5, include=FALSE}
rm(atlas.metadata)
gc()
```

```{r atlas_subsetting}
Idents(atlas) <- atlas$day
atlas.subset <- subset(x = atlas, idents = c("mixed_gastrulation"), invert=T)

Idents(atlas.subset) <- atlas.subset$celltype
atlas.subset <- subset(x = atlas.subset, cells = colnames(atlas.subset)[is.na(Idents(atlas.subset))], invert = T)
atlas.subset <- subset(atlas.subset, idents=unique(grep("ExE", atlas.subset$celltype, value = T)), invert=T)
atlas.subset <- subset(atlas.subset, idents="Parietal endoderm", invert=T)
```

```{r garbage-collec6, include=FALSE}
rm(atlas)
gc()
```

##### Atlas preprocessing

```{r hvg-vst-atlas, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp"}
atlas.subset <- FindVariableFeatures(atlas.subset, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
saveRDS(atlas.subset, file.path(rdsObjects, paste0("XX_atlas_before_integ_with_", dataset, ".rds")))
```

```{r hvg-mvp-atlas, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp", results='asis'}
atlas.subset <- FindVariableFeatures(atlas.subset, selection.method = hvg.meth, verbose=FALSE)
saveRDS(atlas.subset, file.path(rdsObjects, paste0("XX_atlas_before_integ_with_", dataset, ".rds")))
```

```{r show-HVGnum-atlas, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
t(as.data.frame(table(atlas.subset@assays[["RNA"]]@meta.features$mvp.variable))) %>%
  knitr::kable(caption = "Number of features selected as highly variable genes (HVG)",
               row.names = FALSE,
               escape = F,
               align = "cc") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r preprocess-atlas1, results='hold'}
atlas.subset <- ScaleData(atlas.subset, do.scale = FALSE, verbose = FALSE)
atlas.subset <- RunPCA(atlas.subset, npcs = top.pcs, verbose = FALSE)
gc()
```

##### Transfert learning from the Atlas

```{r mapping-atlas}
anchors <- FindTransferAnchors(reference = atlas.subset, query = SO,
                               dims = 1:top.pcs, reference.reduction = "pca")
predictions <- TransferData(anchorset = anchors, refdata = atlas.subset$celltype,
                            dims = 1:top.pcs)
SO <- AddMetaData(SO, metadata = predictions)
SO$celltype_DF <- SO$predicted.id
SO$predicted.id <- NULL
```

```{r plot-DF-celltype, fig.show='hold'}
Idents(SO) <- SO@meta.data$celltype_DF

DimPlot(SO,
        pt.size = 1,
        label = FALSE,
        cols = colors.celltype[levels(Idents(SO))]) +
  ggtitle(paste0(dataset, " : cell identities")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        # axis.ticks = element_blank()
        line = element_blank())

DimPlot(SO,
        pt.size = 1,
        label = FALSE,
        cols = colors.celltype[levels(Idents(SO))],
        split.by = 'celltype_DF', ncol=3) +
  NoLegend() +
  ggtitle(paste0(dataset, " : cell identities separately")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        # axis.ticks = element_blank()
        line = element_blank())
```

#### Number of cells to label as doublet (ie. heterotypic doublets)

```{r homotypic-proportion}
# based on annotation (celltype)
# could be also the louvain clusters determined from the preprocessus step
annotations <- SO@meta.data$celltype_DF
homotypic.prop <- modelHomotypic(annotations)
```

```{r heterotypic-estimation}
# based on annotation (celltype)
# could be also the louvain clusters determined from the preprocessus step
nDoublets <- round(ncol(SO)*dblt.rate/100)
nDoublets_nonhomo <- round(nDoublets*(1-homotypic.prop))
```

There are `r nDoublets_nonhomo` cells estimated as heterotypic doublets.

### Neighborhood size optimization (pK parameter)

```{r generate-pKs, results='hide', fig.show='hide'}
sweep.res <- paramSweep_v3(SO, PCs = 1:top.pcs) # as estimated from PC elbowPlot
sweep.stats_SO <- summarizeSweep(sweep.res, GT = FALSE)
Sys.sleep(0.5)
bcmvn_SO <- find.pK(sweep.stats_SO)
```

```{r optimize-pK}
ggplot(bcmvn_SO, aes(pK, BCmetric, group = 1)) +
  geom_point() +
  geom_line()

pK <- bcmvn_SO %>% # select the pK that corresponds to max bcmvn to optimize doublet detection
  filter(BCmetric == max(BCmetric)) %>%
  select(pK) 
pK <- as.numeric(as.character(pK[[1]]))
```

## Doublets identification - DoubletFinder run

```{r runDF}
SO <- doubletFinder_v3(SO, 
                       PCs = 1:top.pcs, 
                       pN = 0.25,
                       pK = pK, 
                       nExp = nDoublets_nonhomo)
```

```{r plot-doublets, fig.align='default', out.width='50%', fig.show='hold'}
# remove the cells identified as doublets of each of the sub-datasets
col_dblts <- grep("DF.classifications", colnames(SO@meta.data), value=TRUE)
Idents(SO) <- col_dblts

DimPlot(SO,
        pt.size = 1,
        label = T,
        label.size = 6,
        repel = T,
        split.by = col_dblts, ncol=3) +
  NoLegend() +
  ggtitle(paste0(dataset, " : doublets prediction")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        # axis.ticks = element_blank()
        line = element_blank())

FeaturePlot(SO, features = "nCount_RNA",
        pt.size = 1) +
        ggtitle(paste0(dataset, " : numbre of UMIs")) +
        theme(plot.title = element_text(hjust = 0.5),
            axis.text = element_blank(),
            # axis.ticks = element_blank()
            line = element_blank())
```

```{r df-count-celltypeDF}
Idents(SO) <- col_dblts
celltypeDF <- as.data.frame.matrix(table(Idents(SO), SO@meta.data$celltype_DF))

celltypeDF %>%
  knitr::kable(caption = "Doublet ratio over celltypes got from Rossi et al. classifier") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")
```

```{r df-count-cluster}
clustersRes <- grep(paste0("res.", res, "$"), colnames(SO@meta.data), value=TRUE)
clusterDF <- as.data.frame.matrix(table(Idents(SO), SO@meta.data[,which(colnames(SO@meta.data) == clustersRes)])) 

clusterDF %>%
  knitr::kable(caption = paste0("Doublet ratio over clusters at resolution ", res)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")
```

## Subset to singlets

```{r remove-doublets}
SOsing <- subset(SO, idents='Singlet')

# remove useless columns
SOsing@meta.data[[grep("DF.classifications", colnames(SOsing@meta.data))]] <- NULL
names(SOsing@meta.data)[names(SOsing@meta.data) == grep("pANN", colnames(SOsing@meta.data), value=T)] <- "pANN"
```

```{r size-singlets}
size_track3 <- data.frame(cbind(
  t(dim(SOsing)),
  "Removed doublets",
  "03"
))
colnames(size_track3) <- c('Nbr_of_features', 'Nbr_of_cells', 'Analysis_step_name', 'Step_number')
size_track3$Nbr_of_cells <- as.integer(as.character(size_track3$Nbr_of_cells))
size_track3$Nbr_of_features <- as.integer(as.character(size_track3$Nbr_of_features))
```

```{r plot-evolution2}
ggplot(rbind(size_track1, size_track2, size_track3), aes(x = Analysis_step_name, y = Nbr_of_cells)) +
  geom_col(aes(color = Analysis_step_name, fill = Analysis_step_name), position = position_dodge(), width = 0.6) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20),
        axis.title.x = element_blank()) +
  scale_x_discrete(labels = label_wrap(6)) +
  ggtitle(paste0("Evolution of the number of cells in the dataset\n", dataset)) +
  NoLegend() +
  ylab('Number of cells')
```

<!-- ```{r save2} -->
<!-- saveRDS(SOsing, file=file.path(rdsObjects, paste0("02_removedDoublets_", dataset, ".rds"))) -->
<!-- ``` -->

```{r garbage-collec2, include=FALSE}
rm(SO)
gc()
```

<!-- ```{r setup5, eval=TRUE, include=FALSE} -->
<!-- knitr::opts_chunk$set( -->
<!--     # code evaluation -->
<!--     eval = FALSE, -->
<!--     echo = FALSE -->
<!-- ) -->
<!-- ``` -->
<!--  -->
<!-- ```{r restart2} -->
<!-- SOsing <- readRDS(file.path(rdsObjects, paste0("02_removedDoublets_", dataset, ".rds"))) -->
<!-- ``` -->
<!--  -->
<!-- ```{r setup6, eval=TRUE, include=FALSE} -->
<!-- knitr::opts_chunk$set( -->
<!--     # code evaluation -->
<!--     eval = TRUE, -->
<!--     echo = TRUE -->
<!-- ) -->
<!-- ``` -->

# Preprocessing workflow after doublets removal

```{r hvg-vst2, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp"}
SOsing <- FindVariableFeatures(SOsing, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
```

```{r hvg-mvp2, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
SOsing <- FindVariableFeatures(SOsing, selection.method = hvg.meth, verbose=FALSE)
head(SOsing@assays[["RNA"]]@meta.features) %>%
  knitr::kable(caption = "Example of HVG selection output") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r show-HVGnum2, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
t(as.data.frame(table(SOsing@assays[["RNA"]]@meta.features$mvp.variable))) %>%
  knitr::kable(caption = "Number of features selected as highly variable genes (HVG)",
               row.names = FALSE,
               escape = F,
               align = "cc") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```


```{r preprocess2-1, results='hold'}
var.feats.dataset <- VariableFeatures(SOsing)
saveRDS(var.feats.dataset, file=file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds")))

SOsing <- ScaleData(SOsing, features=rownames(SOsing), do.scale=do.scale, verbose=FALSE)
SOsing <- RunPCA(SOsing, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r plot-elbow2}
ElbowPlot(SOsing, ndims = pca.npcs) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color = "purple", size = 1) +
  ggtitle(paste0(SOsing@project.name, "\nElbowPlot"))
```

```{r preprocess2-2}
SOsing@meta.data[grep("RNA_snn", names(SOsing@meta.data))] <- NULL
resolutions <- seq(0.6, 1.6, 0.1)
SOsing <- FindNeighbors(SOsing, dims = 1:top.pcs, verbose=FALSE)
SOsing <- FindClusters(SOsing, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
SOsing <- RunUMAP(SOsing, dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE)
```

```{r plot-clusters-2, fig.align='default', out.width="50%", fig.show='hold'}
for (ares in resolutions){
  clusterResName <- grep(paste0("RNA_snn_res.", ares, "$"), colnames(SOsing@meta.data), value = TRUE)
  Idents(SOsing) <- clusterResName
  
  DimPlot(SOsing,
          pt.size = 1,
          label = TRUE,
          label.size = 6,
          repel = TRUE) +
    NoLegend() +
    ggtitle(paste0(dataset, " : clusters at resolution ", ares)) +
    theme(plot.title = element_text(hjust = 0.5),
          axis.text = element_blank(),
          # axis.ticks = element_blank()
          line = element_blank())
  
  Sys.sleep(0.5)
}
```

<!-- ```{r save4} -->
<!-- saveRDS(SOsing, file=file.path(rdsObjects, paste0("03_WF_onSinglets_", dataset, ".rds"))) -->
<!-- ``` -->
<!--  -->
<!-- ```{r setup7, eval=TRUE, include=FALSE} -->
<!-- knitr::opts_chunk$set( -->
<!--     # code evaluation -->
<!--     eval = FALSE, -->
<!--     echo = FALSE -->
<!-- ) -->
<!-- ``` -->
<!--  -->
<!-- ```{r restart3} -->
<!-- SOsing <- readRDS(file.path(rdsObjects, paste0("03_WF_onSinglets_", dataset, ".rds"))) -->
<!-- ``` -->
<!--  -->
<!-- ```{r setup8, eval=TRUE, include=FALSE} -->
<!-- knitr::opts_chunk$set( -->
<!--     # code evaluation -->
<!--     eval = FALSE, -->
<!--     echo = FALSE -->
<!-- ) -->
<!-- ``` -->

```{r garbage-collec3, include=FALSE}
gc()
```

- - -

\clearpage

# Transfert learning from the Atlas {.tabset .tabset-pills .tabset-fade}

## Cell identity transfert

```{r mapping-atlas2}
anchors <- FindTransferAnchors(reference = atlas.subset, query = SOsing,
                               dims = 1:top.pcs, reference.reduction = "pca")
predictions <- TransferData(anchorset = anchors, refdata = atlas.subset$celltype,
                            dims = 1:top.pcs)
SOsing <- AddMetaData(SOsing, metadata = predictions)
SOsing$celltype <- SOsing$predicted.id
SOsing$predicted.id <- NULL
```

```{r plot-celltype}
Idents(SOsing) <- SOsing@meta.data$celltype
DimPlot(SOsing,
        pt.size = 1,
        label = FALSE,
        cols = colors.celltype[levels(Idents(SOsing))],
        split.by = "celltype",
        ncol = 3) +
  NoLegend() +
  ggtitle(paste0("Celltypes of the analysed data after cell identity transfert\n", dataset)) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        # axis.ticks = element_blank()
        line = element_blank())
```

```{r setup9, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart4}
SOsing <- readRDS(file.path(rdsObjects, paste0("04_celltypeFromAtlas_", dataset,"_with_atlas.rds")))
atlas.subset <- readRDS(file.path(rdsObjects, paste0("XX_atlas_before_integ_with_", dataset, ".rds")))
var.feats.dataset <- readRDS(file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds")))
```

```{r setup10, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  echo = TRUE
)
```

## Global orientation of the UMAP plots

### Integrate analyzed data with the Atlas

```{r integration-with-atlas}
features <- SelectIntegrationFeatures(object.list = list(SOsing, atlas.subset))
anchors <- FindIntegrationAnchors(object.list = list(SOsing, atlas.subset), anchor.features = features)
SO.align <- IntegrateData(anchorset = anchors)

SO.align@project.name <- paste0(dataset, "_with_atlas")
DefaultAssay(SO.align) <- "integrated"

SO.align <- ScaleData(SO.align, assay = DefaultAssay(SO.align), do.scale=do.scale, verbose = FALSE)
SO.align <- RunPCA(SO.align, npcs = pca.npcs, verbose = FALSE)
ElbowPlot(SO.align, ndims = pca.npcs)
```

```{r show-alignedUMAP}
SO.align <- RunUMAP(SO.align, reduction = "pca", dims = 1:10)

Idents(SO.align) <- "model"

DimPlot(SO.align,
        pt.size = 1,
        label = TRUE,
        label.size = 6,
        repel = TRUE,
        split.by = "model",
        ncol = 2) +
  ggtitle("Gastruloid and atlas cells\nin a shared UMAP embedding") +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        # axis.ticks = element_blank()
        line = element_blank())
```

### Get UMAP of a subset of the Atlas data

```{r atlas_refLayout}
spread <- 2
min_dist <- 1
Idents(atlas.subset) <- 'celltype'

# Downsample the number of cells per identity class
set.seed(general.seed)
cells.use <- WhichCells(object = atlas.subset, downsample = 200) #colnames(atlas.subset) #sample(colnames(atlas.subset),1000)
nn=300
local_connectivity=1 # Tried 2 and was not so convincing. Should not be more than the local intrinsic dimension of the manifold.
fast_sgd <- F # Should set it to FALSE ultimately, to get exactly reproducible results, but TRUE can be useful as it is faster for early exploration.
umap_init <- "spectral" # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates.
reduction.use <- "pca"

set.seed(general.seed)
tmp <- umap(X = Embeddings(atlas.subset[[reduction.use]])[cells.use, 1:10],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T,
            verbose = F)
tmp2 <- 0*Embeddings(atlas.subset[[reduction.use]])[, 1:3]
tmp2[cells.use, ] <- tmp$embedding
atlas.subset[["umap200"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP200_")
```

UMAP dimension reduction on atlas, with 200 cells per celltype, 300 neighbors

```{r plot-atlasUMAP-200}
DimPlot(atlas.subset, pt.size = 1, reduction = "umap200", label = T, cells = sample(cells.use),
        repel = TRUE, cols = colors.celltype[levels(Idents(atlas.subset))]) +
  NoLegend() +
  ggtitle(paste0(dataset, " : atlas celltypes\nvisualization reduced to 200 cells per celltype")) +
  CenterTitle() +
  NoAxes()
```

<!-- ```{r save-atlasUMAP-200} -->
<!-- saveRDS(atlas.subset, file=file.path(rdsObjects, paste0("05_UMAP_atlas_subset200cells_", dataset, ".rds"))) -->
<!-- ``` -->

#### Create a centroid table on Atlas cell types in UMAP200 space

```{r atlas_cluster_avg.pos}
Idents(atlas.subset) <- atlas.subset$celltype
x_ref <- data.frame(row.names = unique(atlas.subset$celltype))
for(i in unique(atlas.subset$celltype)){
  x_ref[i,1] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),1])
  x_ref[i,2] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),2])
  x_ref[i,3] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),3])
}
```

#### Create random initial coordinates for the integrated object based on the centroid table

```{r UMAPinit_sharedLayout}
min_dist <- 8
spread <- 25
nn <- 300

# Generate a random position around the layout defined positions for all cells according to their cell types:
noise <- 5
set.seed(general.seed)
x_ini <- data.frame(row.names = colnames(SO.align))
x_ini[,1] <- runif(length(colnames(SO.align)))*noise
x_ini[,2] <- runif(length(colnames(SO.align)))*noise
x_ini[,3] <- runif(length(colnames(SO.align)))*noise
Idents(SO.align) <- SO.align$celltype
for(i in unique(SO.align$celltype)){
  if(i %in% rownames(x_ref)){
    x_ini[WhichCells(SO.align,idents=i),1] <- x_ini[WhichCells(SO.align,idents=i),1]+x_ref[i,1]
    x_ini[WhichCells(SO.align,idents=i),2] <- x_ini[WhichCells(SO.align,idents=i),2]+x_ref[i,2]
    x_ini[WhichCells(SO.align,idents=i),3] <- x_ini[WhichCells(SO.align,idents=i),3]+x_ref[i,3]
  }
}
```

```{r garbage-collec9, include=FALSE}
gc()
```

#### Compute UMAP dimension reduction on the integrated object, nested by the random initial coordinates

```{r apply_UMAPshared}
cells.use <- colnames(SO.align) #WhichCells(object = tmp,downsample = 300) #colnames(SO) #sample(colnames(SO),1000)

local_connectivity=1 # Should not be more than the local intrinsic dimension of the manifold. I would have imagined 2-3 could be reasonable, but doesn't give good results. 
fast_sgd <- T # Should set it to false ultimately, to get exactly reproducible results, but can use T to get faster for early exploration. 
umap_init <- as.matrix(x_ini[cells.use,]) # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates. 

set.seed(general.seed)
reduction.use <- "pca"
tmp <- umap(X = Embeddings(SO.align[[reduction.use]])[cells.use, 1:10],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T, 
            verbose = F)
tmp2 <- 0*Embeddings(SO.align[[reduction.use]])[,1:3]
tmp2[cells.use,] <- tmp$embedding
SO.align[["umapShared3d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAPshared3d_", assay = DefaultAssay(SO.align))


umap_init <- as.matrix(x_ini[cells.use, 1:2]) # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates. 

set.seed(general.seed)
reduction.use <- "pca"
tmp <- umap(X = Embeddings(SO.align[[reduction.use]])[cells.use, 1:10],
            init = umap_init,
            n_neighbors = nn,
            n_components = 2,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T, 
            verbose = F)
tmp2 <- 0*Embeddings(SO.align[[reduction.use]])[,1:2]
tmp2[cells.use,] <- tmp$embedding
SO.align[["umapShared2d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAPshared2d_", assay = DefaultAssay(SO.align))
```

```{r plot-SOalign-umapShared2d}
DimPlot(SO.align, pt.size = 1, reduction = "umapShared2d", label = T, 
        repel = TRUE, cols = colors.celltype[levels(Idents(atlas.subset))]) + 
  NoLegend() +
  ggtitle(paste0(dataset, " : celltype layout\non the integrated object")) +
  CenterTitle() +
  NoAxes()
```

<!-- ```{r save6} -->
<!-- saveRDS(SO.align, file=file.path(rdsObjects, paste0("05_UMAP_shared_", SO.align@project.name, ".rds"))) -->
<!-- ``` -->

```{r garbage-collec10, include=FALSE}
rm(tmp, tmp2, cells.use, x_ref, x_ini)
gc()
```

```{r setup11, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart5}
SO.align <- readRDS(file.path(rdsObjects, paste0("05_UMAP_shared_", dataset, "_with_atlas.rds")))
var.feats.dataset <- readRDS(file=file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds")))
```

```{r setup12, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  echo = TRUE
)
```

# `r dataset` data analysis after label transfert and initialized UMAP coordinates

```{r extract-dataset}
cells.use <- colnames(SO.align)[SO.align$model == "Gastruloids"]
SO <- SO.align[, cells.use]
SO@project.name <- dataset
```

```{r set-DefaultAssay}
DefaultAssay(SO) <- "RNA"
```

## Analyzed data preprocessing

```{r set-HVG, results='hold'}
VariableFeatures(SO) <- var.feats.dataset
SO <- ScaleData(SO, features=rownames(SO), do.scale=do.scale, verbose=FALSE)
SO <- RunPCA(SO, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r plot-elbow3}
ElbowPlot(SO, ndims = pca.npcs) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color="purple", size=1) +
  ggtitle(paste0(SO@project.name, "\nElbowPlot"))        
```

## Run UMAP algorithm, nested on atlas coordinates

```{r UMAP-dataset}
# Create 3-dimensional UMAP coordinates
SO[["umapShared3d"]] <- CreateDimReducObject(embeddings = Embeddings(SO.align$umapShared3d)[cells.use,], key = "UMAPshared3d_", assay = DefaultAssay(SO))

init_sdev <- 1e-4
noise_level <- 0
min_dist <- 6
spread <- 15
nn <- 300

umap_init <- as.matrix(Embeddings(SO[["umapShared3d"]]))
set.seed(general.seed)
umap_init <- umap_init + cbind(rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level))
set.seed(general.seed)
reduction.use <- "pca" # pca1 or harmony
tmp <- umap(X = Embeddings(SO[[reduction.use]])[colnames(SO), 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            local_connectivity=1,
            ret_model=T,
            verbose = F,
            n_epochs = 1000,
            learning_rate = 1,
            init_sdev = init_sdev)

tmp2 <- 0*Embeddings(SO[["pca"]])[,1:3]
tmp2[colnames(SO),] <- tmp$embedding
SO[["umap3d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP3d_", assay = DefaultAssay(SO))

# Create 2-dimensional UMAP coordinates
SO[["umapShared2d"]] <- CreateDimReducObject(embeddings = Embeddings(SO.align$umapShared2d)[cells.use,], key = "UMAPshared2d_", assay = DefaultAssay(SO))

umap_init <- as.matrix(Embeddings(SO[["umapShared2d"]]))
set.seed(general.seed)
umap_init <- umap_init + cbind(rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level))
set.seed(general.seed)
reduction.use <- "pca" # pca1 or harmony
tmp <- umap(X = Embeddings(SO[[reduction.use]])[colnames(SO), 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 2,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            local_connectivity=1,
            ret_model=T,
            verbose = F,
            n_epochs = 1000,
            learning_rate = 1,
            init_sdev = init_sdev)

tmp2 <- 0*Embeddings(SO[["pca"]])[,1:2]
tmp2[colnames(SO),] <- tmp$embedding
SO[["umap2d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP2d_", assay = DefaultAssay(SO))
```

<!-- ```{r save7} -->
<!-- saveRDS(SO, file=file.path(rdsObjects, paste0("06_umap_2d3d_", SO@project.name, ".rds"))) -->
<!-- ``` -->

```{r garbage-collec11, include=FALSE}
rm(umap_init, tmp, tmp2)
gc()
```

```{r show-umap2d, fig.show='hold'}
Idents(SO) <- "celltype"

plot1 <- DimPlot(SO,
                 pt.size = 1,
                 reduction = "umap2d",
                 label = TRUE,
                 label.size = 6,
                 repel = TRUE,
                 cols = colors.celltype[levels(Idents(SO))]) +
  NoLegend() +
  ggtitle(paste0(dataset, " cells in UMAP embbeding\nnested on atlas UMAP coordinates")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        # axis.ticks = element_blank()
        line = element_blank())

plot2 <- DimPlot(SO,
                 pt.size = 1,
                 reduction = "umap2d",
                 cols = colors.celltype[levels(Idents(SO))],
                 split.by = "celltype",
                 ncol = 4) +
  NoLegend() +
  ggtitle(paste0(dataset, " cells in UMAP embbeding\nnested on atlas UMAP coordinates")) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        # axis.ticks = element_blank()
        line = element_blank())

plot1
plot2
```

```{r setup13, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart6}
SO <- readRDS(file.path(rdsObjects, paste0("06_umap_2d3d_", SO@project.name, ".rds")))
```

```{r setup14, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = TRUE,
  echo = TRUE
)
```

## Clustering (FindNeighbors, FindClusters)

```{r clustering3}
resolutions <- seq(0.6, 1.6, 0.1)
SO <- FindNeighbors(SO, dims = 1:top.pcs, verbose=FALSE)
SO <- FindClusters(SO, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
```

```{r save8}
saveRDS(SO, file=file.path(rdsObjects, paste0("07_clusters_", SO@project.name, ".rds")))
```

```{r garbage-collec12, include=FALSE}
gc()
```

```{r show-clustering, eval=FALSE}
clustersColor <- setNames(hue_pal()(length(names(topMarkers))), names(topMarkers))
selectedRes <- grep(paste0(DefaultAssay(SO), ".*res.", res, "$"), colnames(SO@meta.data), value=TRUE)

Idents(SO) <- SO@meta.data[[selectedRes]]

DimPlot(SO,
        pt.size = 1,
        reduction = "umap2d",
        label = TRUE,
        label.size = 6,
        repel = TRUE,
        cols = clustersColor[levels(Idents(SO))]) +
  NoLegend() +
  ggtitle(NA) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text = element_blank(),
        # axis.ticks = element_blank()
        line = element_blank())
```

```{r setup15, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart7}
SO <- readRDS(file.path(rdsObjects, paste0("07_clusters_", dataset, ".rds")))
```

```{r setup16, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

## Differential expression analysis

```{r selected-resolution}
#SO$seurat_clusters <- NULL
selectedRes <- grep(paste0(DefaultAssay(SO), ".*res.", res, "$"), colnames(SO@meta.data), value=TRUE)
SO$clusters <- SO[[selectedRes]]
Idents(SO) <- SO$clusters
```

```{r findAllMarkers}
DefaultAssay(SO) <- 'RNA'

markers <- FindAllMarkers(SO, only.pos = TRUE)
#markers.sign <- markers[markers$p_val_adj < 0.001 & markers$avg_logFC > log(1.5), ]
markers.sign <- markers[order(-markers$avg_log2FC), ]
markers.sign <- markers.sign[order(markers.sign$cluster), ]
markers.sign <- markers.sign[ , c(6, 7, 2:4, 1, 5)]
write.table(x = markers.sign, file = file.path(dataset.anFolder,
                                               paste0("markers_min.pct_logFC_default_", 
                                                      dataset, ".integ.res_", selectedRes, ".csv")), sep = ",", row.names = F, col.names = T)
```

```{r topNmarkers}
topNmarkers <- extract_topn(markers.sign, topn = top.markers)

dominantCelltypes <- add_dominantMetadata(SO, metadata = "celltype")
topNmarkers <- left_join(topNmarkers, dominantCelltypes, by='cluster')
```

```{r addDay_dominantMetadata, eval=(do.integ || do.merge), echo=(do.integ || do.merge)}
dominantDays <- add_dominantMetadata(SO, metadata = "day")
topNmarkers <- left_join(topNmarkers, dominantDays, by='cluster')
```

```{r saveTopNmarkers}
write.table(x = topNmarkers, file = file.path(dataset.anFolder, paste0("top_", top.markers, "_markers.csv")), sep = ",", row.names = F, col.names = T)
```

```{r displayTable}
datatable(topNmarkers, rownames = FALSE, filter = "top", options = list(pageLength = 5, scrollX=T))
```

```{r setup17, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

```{r restart8}
SO <- readRDS(file.path(rdsObjects, paste0("07_clusters_", dataset, ".rds")))
selectedRes <- grep(paste0(DefaultAssay(SO), ".*res.", res, "$"), colnames(SO@meta.data), value=TRUE)
markers.sign <- read.table(file.path(dataset.anFolder, paste0("markers_min.pct_logFC_default_", dataset, ".integ.res_", selectedRes, ".csv")), sep = ",", header = T)
```

```{r setup18, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
  # code evaluation
  eval = FALSE,
  echo = FALSE
)
```

# Additional Plots

```{r addPlots-1}
# Load list of genes of interest
goi <- read.table(file.path(otherInputs, "genes_of_interest3-scRNAseq.tsv"), sep = ",")
goiList <- goi$V1

# Parameters
ntop <- 5
```

```{r addPlots-2}
DefaultAssay(SO) <- "RNA"
topNmarkers <- extract_topn(markers.sign, topn = ntop)
topNgenes <- unique(topNmarkers$gene)
```

```{r clean-goiList}
genesToRemove <- goiList[!(goiList %in% rownames(SO))]
if (length(genesToRemove) >= 1){
  cat(paste0("One or more genes of interest are not in the dataset (maybe because of the case):\n\t",
             str_c(genesToRemove, collapse = ", "), "\nThe listed genes are to be removed of the plots"))
}
goiList <- goiList[goiList %in% rownames(SO)] # remove the 
```

## Cluster identity {.tabset .tabset-pills .tabset-fade}

```{r addPlots-3}
Idents(SO) <- factor(SO@meta.data$RNA_snn_res.1, levels = sort(as.numeric(levels(as.factor(SO@meta.data$RNA_snn_res.1)))))
```

### DimPlot of the cluster identity
```{r cluster-dimplot}
p <- DimPlot(SO, reduction = "umap2d", pt.size = 0.8,
             label = FALSE) +
  ggtitle(paste0("Clusters at resolution 1\n", SO@project.name)) +
  CenterTitle() +
  NoAxes()
LabelClusters(p, id = "ident",  fontface = "bold", size = 5)
```

### DotPlot of the markers on cluster identity

```{r cluster-dotPlot-markers}
dotPlotsMarkers(SO, topNgenes, title=paste0("Top ", ntop, " markers of each cluster in clusters"))
```

### DotPlot of the genes of interest on cluster identity

```{r cluster-dotPlot-goi}
dotPlotsGoi(SO, goiList, title="Genes of interest in clusters")
```

### FeaturePlot of the markers {.tabset .tabset-pills .tabset-fade}

```{r results='asis', out.width='20%', fig.align='default'}
# code with the courtesy of Lionel Spinelli and Romain Fenouil
topMarkers = by( markers.sign, markers.sign[["cluster"]], function(x)
{
  # Filter markers based on adjusted PValue
  x = x[ x[["p_val_adj"]] < 0.005, , drop = FALSE];
  # Sort by decreasing logFC
  x = x[ order(abs(x[["avg_log2FC"]]), decreasing = TRUE), , drop = FALSE ]
  # Return top ones
  return( if(is.null(  top.markers )) head( x, n =  10 ) else head( x, n =  min(top.markers, 10) ));
});

clustersColor <- setNames(hue_pal()(length(names(topMarkers))), names(topMarkers))

invisible( lapply( names( topMarkers), function(clusterName)
{
  cat("##### Cluster <span style='border-radius: 3px; border: 3px solid ", clustersColor[clusterName], "; padding:0px 2px'>", clusterName, "</span>\n");
  
  # Highlight cells of current cluster on a dimreduc plot
  highlightClusterPlot(clusterName, seuratObject = SO, reduction = ifelse( exists("useReduction"), useReduction, "umap2d"));
  
  # Plots expression on projected cells
  invisible( lapply( topMarkers[[clusterName]][["gene"]], function(featureName)
  {
    print( FeaturePlot( SO, features = featureName, reduction = ifelse( exists("useReduction"), useReduction, "umap2d"), order = TRUE) +
             theme( axis.title.x = element_blank(),
                    axis.title.y = element_blank(),
                    legend.position = "none"));
  }));
  
  cat(" \n \n"); # Required for '.tabset'
}))
```

```{r cluster-featurePlot-markers}
## FeaturePlot the genes of interest
doFeaturePlot(SO, topNgenes)
```

### FeaturePlot of the genes of interest with cluster labels

```{r cluster-featurePlot-goi}
## FeaturePlot the genes of interest
doFeaturePlot(SO, goiList)
```

### ViolinPlots of the markers {tabset .tabset-pills .tabset-fade}

```{r results='asis'}
# with courtesy of Lionel Spinelli and Romain Fenouil
invisible( lapply( names( topMarkers), function(clusterName)
{
  cat("##### Cl. <span style='border-radius: 3px; border: 3px solid ", clustersColor[clusterName], "; padding:0px 2px'>", clusterName, "</span>\n");
  
  # Remind cluster name in an empty figure to keep consistent alignment of panels between tabs
  plot( c( 0, 1), c( 0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n');
  text( x = 0.5, y = 0.5, paste( "Cluster", clusterName), cex = 2, col = clustersColor[clusterName]);
  
  # Violinplot for expression value of marker genes by cluster (+ number of 'zero' and 'not zero' cells)
  invisible( lapply( topMarkers[[clusterName]][["gene"]], violinFeatureByCluster, seuratObject = SO, clustersColor = clustersColor));
  
  cat(" \n \n"); # Required for '.tabset'
}));
```

## Celltype identity {.tabset .tabset-pills .tabset-fade}

```{r addPlots-4}
Idents(SO) <- factor(SO@meta.data$celltype, levels = sort(levels(as.factor(SO@meta.data$celltype))))
```

### DimPlot of the celltype identity

```{r celltype-dimplot}
## DimPlot the celltype
p <- DimPlot(SO, reduction = "umap2d", pt.size = 0.8,
             label = FALSE) +
  ggtitle(paste0("Celltype from atlas transfert identity labels\n", SO@project.name)) +
  CenterTitle() +
  NoAxes()
LabelClusters(p, id = "ident",  fontface = "bold", size = 5)
```

### DotPlot of the markers on celltype identity

```{r celltype-dotPlot-markers}
## DotPlot the n-top markers of each celltype
dotPlotsMarkers(SO, topNgenes, title=paste0("Top ", ntop, " markers of each cluster in celltypes"))
```

### DotPlot of the genes of interest on celltype identity

```{r celltype-dotPlot-goi}
## DotPlot the genes of interest
dotPlotsGoi(SO, goiList, title="Genes of interest in celltypes")
```

