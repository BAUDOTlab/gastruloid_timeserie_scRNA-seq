---
author: "CC"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output:
    html_document:
        theme:
            bootswatch: yeti
        toc: yes
        toc_float:
          collapsed: false
          smooth_scroll: true
        number_sections: yes
        df_print: kable
        code_folding: hide
    pdf_document:
        number_sections: yes
        toc: yes
        toc_depth: 3
        keep_tex: no
params:
    new.analysis:
        value: FALSE
    dataset:
        value: NA
        choices: [lab_day_04, lab_day_05, lab_day_05bis, lab_day_06, lab_day_11]
    do.integ:
        value: FALSE
    do.merge:
        value: FALSE
    mito.low:
        value: 1.5
        min: 0
        max: 99
    mito.high:
        value: 10
        min: 1
        max: 100
    ribo.low:
        value: 25
        min: 0
        max: 99
    ribo.high:
        value: 45
        min: 1
        max: 100
    min.feat:
        value: 200
    min.cells:
        value: 3
    min.counts:
        value: 1500
    max.counts:
        value: 150000
    norm.meth:
        value: "LogNormalize"
    hvg.meth:
        value: mvp
        choices: [vst, mvp, disp]
    hvg.num:
        value: FALSE
    do.scale:
        value: FALSE
    pca.npcs:
        value: 30
    pca.print:
        value: 10
    top.pcs:
        value: 15
    dblt.rate:
        value: 8
    res:
        value: 1.0
    algo.cluster:
        value: 4
        choices: [1, 2, 3, 4]
    top.markers:
        value: 20
    general.seed: 17
title: "Protocole 1: `r params$dataset`"
---

```{r setup1, eval=TRUE, include=FALSE}
options(knitr.purl.inline = TRUE)
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,

    # text output
    echo = TRUE,
    results = "hold",
    warning = FALSE,
    error = FALSE,
    message = FALSE,
    strip.white = TRUE,

    # code decoration
    #tidy = TRUE,
    tidy.opts = list(width.cutoff = 90),
    comment = '',
    attr.output='.numberLines',
    
    # plots
    #fig.path = "figure/",      # is set later, in chunk setup2
    fig.show = "asis",         # tuned to "hold" in multiple plots chunk
    dev = c('png', 'pdf'),
    fig.width = 12,
    fig.height = 12,
    #fig.asp=1.3               # fig.height = fig.width * fig.asp
    #out.extra = 'style="border:5px solid orange;"'     # orange box arround plots
    fig.align = "center"       # should be tuned to default in multiple plots chunk
)
```

```{r load-lib, include=FALSE}
library(dplyr)
library(Matrix)
library(Seurat)
library(ggplot2)
library(reticulate)
library(scmap)
#library(RColorBrewer)
library(DoubletFinder)
library(stringr)
library(kableExtra)
library(formattable)
library(knitr)
library(SingleCellExperiment)
library(BiocGenerics)
library(scales)
library(formatR)
library(uwot)
library(DT)

options(ggrepel.max.overlaps = Inf)
```

```{r get-params, include=FALSE}
bindingIsLocked("params", env = .GlobalEnv)
unlockBinding("params", env = .GlobalEnv)
attach(params)
```

```{r sourceCodes}
source("./dimplotMetadata.R")
source("./extract_topn.R")
source("./add_dominantMetadata.R")
#source("/mnt/DATA_4TB/projects/XX/analysis/seuratAnalysis/scripts/lionel_codes/FeatureViolinplot.R")
#source("/mnt/DATA_4TB/projects/XX/analysis/seuratAnalysis/scripts/lionel_codes/Violin_dotplot.R")
```


# Global settings {.tabset .tabset-pills .tabset-fade} {.bs-callout .bs-callout-orange}

## `r dataset` setting analysis

```{r show-params}
ul <- unlist(params)
df <- data.frame(keyName=names(ul), value=ul, row.names=NULL)
names(df) <- c('Parameters', 'Values')
df1 <- df[1:ceiling(dim(df)[1]/3),]
df1$Parameters <- cell_spec(df1$Parameters, bold = T)
df2 <- df[(ceiling(dim(df)[1]/3)+1):(2*ceiling(dim(df)[1]/3)),]
df2$Parameters <- cell_spec(df2$Parameters, bold = T)
df3 <- df[((2*ceiling(dim(df)[1]/3))+1):dim(df)[1],]
df3$Parameters <- cell_spec(df3$Parameters, bold = T)


list(df1, df2, df3) %>%
  knitr::kable(align = "ll", row.names = FALSE, escape = F) %>% 
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE)
rm(df)
```


## Directories

Set either input and output directories.

```{r base-path}
#basePath <- "/home/celine/temp2"
#basePath <- "/mnt/DATA_4TB/projects/XX/analysis/seuratAnalysis" # local server
basePath <- "/shared/projects/XX/XX" # IFB server
```

Root directory for the analysis : `r basePath`

### Input directories

Get the path of the inputs used for the analysis:

- mmgLab.data

- atlas.folder

- classifier.folder

- inputTables.folder

- otherInputs

```{r input-dirs}
inputs.folder <- file.path(basePath, "inputData")

mmgLab.data <- file.path(inputs.folder, "lab_data")
atlas.folder <- file.path(inputs.folder, "atlas")
classifier.folder <- file.path(inputs.folder, "scmap_pijuansala_classifier")
inputTables.folder <- file.path(inputs.folder, "InputTables")
otherInputs <- file.path(inputs.folder, "other")
```

### Output directories

Depending on the previously run analysis, selection of the `baseAnalysis` directory to output
figures, tables and reports.

```{r anteriority}
last_analysis <- 0
dirs.in.dir <- list.dirs(basePath, full.names = FALSE, recursive = FALSE)
anterior <- grep("^analysis_[0-9]+", dirs.in.dir, value = TRUE)
#anterior <- grep("st", dirs.in.dir, value = TRUE)
if (length(anterior) > 0){
    last_analysis <- max(as.numeric(str_extract_all(anterior, "\\d+", simplify = TRUE)), na.rm=T)
} else {
    params$new.analysis <- TRUE
    print(params$new.analysis)
}
```

`r if(new.analysis){"Creation of a new directory"}`

```{r newAnalysis, eval=params$new.analysis, echo=params$new.analysis}
analysis_nb <- paste0("analysis_", as.character(last_analysis+1))
baseAnalysis <- file.path(basePath, analysis_nb)
if(!dir.exists(baseAnalysis)){dir.create(baseAnalysis)}
rdsObjects <- file.path(baseAnalysis, "rdsObjects")
if(!dir.exists(rdsObjects)){dir.create(rdsObjects)}
print(baseAnalysis)
```

`r if(!new.analysis){"Use the previous analysis directory"}`

```{r reAnalysis, eval=!params$new.analysis, echo=!params$new.analysis}
analysis_nb <- paste0("analysis_", as.character(last_analysis))
baseAnalysis <- file.path(basePath, analysis_nb)
rdsObjects <- file.path(baseAnalysis, "rdsObjects")
if(!dir.exists(rdsObjects)){dir.create(rdsObjects)}
print(baseAnalysis)
```

Based on the choosen path, **create** or **reuse** the directory dedicated to the `r dataset` dataset.

```{r dataset-analysisFolder}
dataset.anFolder <- file.path(baseAnalysis, dataset)
if(!dir.exists(dataset.anFolder)){dir.create(dataset.anFolder)}
fig.folder <- file.path(dataset.anFolder, "figures/")
if(!dir.exists(fig.folder)){dir.create(fig.folder)}
```

```{r setup2, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    
    # figures
    fig.path=fig.folder
)
```

## Set up color vectors

```{r load_colorTables}
colors.table <- read.table(file=file.path(inputTables.folder, "ClusterColors.tsv"), sep="\t", header=T, comment.char="", as.is=T)
colors.celltype <- setNames(colors.table$blind_friendly[!is.na(colors.table$transferred_identity)], colors.table$transferred_identity[!is.na(colors.table$transferred_identity)])

colors.stage <- setNames(c("#bb573b", "#ac9d3e", "#5aaf6a", "#7564b9", "#b94c84", "#ba4b7d", "#90b03d", "#60a756", "#45c097", "#5e8bd5", "#6d71d8", "#573585", "#bd80d5", "#b853a2", "#ba4b7d"), c("Day_04", "Day_05", "Day_06", "Day_07", "Day_10", "Day_11", "E6.5", "E6.75", "E7.0", "E7.25", "E7.5", "E7.75", "E8.0", "E8.25", "E8.5"))
```

```{r starter, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

# Get `r dataset` data

## Load data

```{r single-load}
data.path <- file.path(mmgLab.data, dataset)
raw.data <- Read10X(data.dir = data.path, gene = 2)
SO <- CreateSeuratObject(counts=raw.data, project=dataset)
```

## Add/show metadata

```{r add-metaData}
day <- str_to_title(str_extract(dataset, 'day_[0-9]*$'))

SO <- AddMetaData(object = SO, metadata = day, col.name = "day")
SO <- AddMetaData(object = SO, metadata = dataset, col.name = "dataset")
replicateValue <- if (dataset == "lab_day_05bis") 1 else 0
SO <- AddMetaData(SO, metadata = replicateValue, col.name = 'replicate')
SO$model <- "Gastruloids"
```

```{r show-metaData}
data.frame(head(SO@meta.data)) %>%
  knitr::kable(align = "lrrrrrr",
               caption = paste0("First lines of ", dataset, " metadata table")) %>% 
  kable_styling(bootstrap_options = c("striped", "hover"))
```

## Nomenclature for cell names

```{r renaming_cells}
cell_ids <- colnames(SO)
UMIs <- str_extract(cell_ids, '[A-Z]*')
cellnames <- paste(SO$dataset, SO$replicate, UMIs, sep = '_')

SO <- RenameCells(SO, new.names = cellnames)

head(colnames(SO), 3)
```

Below, we can see that there are as many unique cell identifiers as the number of cells among all the sub-datasets.
Nbr of cells among in the dataset: `r dim(SO)[2]`
Nbr of cell identifiers: `r length(unique(colnames(SO)))`

- - -

\clearpage

```{r initial-size, echo=FALSE}
size_track1 <- data.frame(cbind(
    t(dim(SO)),
    "Preliminary Counts",
    "01"
))

colnames(size_track1) <- c('Nbr_of_features', 'Nbr_of_cells', 'Analysis_step_name', 'Step_number')
```

# Quality control

## Percentage of mitochondrial reads & cutoffs

```{r addMitoPercentage}
SO[["percent.mt"]] <- PercentageFeatureSet(SO, pattern="^mt-")      # CHANGE THE PATTERN TO FIT ANY SPECIES
```

```{r plot-mito, fig.align='default', out.width='50%'}
plot1 <- VlnPlot(SO, features = c("percent.mt"), ncol = 3) +
  geom_hline(aes(yintercept = mito.high), color="blue", size=1.5) +
    geom_hline(aes(yintercept = mito.low), color="orange", size=1.5) +
    ggtitle("Mitochondrial expression\npercentage") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()

plot2 <- VlnPlot(SO, features = c("percent.mt"), ncol = 3) +
    geom_hline(aes(yintercept = mito.high), color="blue", size=1.2) +
    geom_hline(aes(yintercept = mito.low), color="orange", size=1.2) +
    ylim(0, 12) +
    ggtitle("Mitochondrial expression\npercentage - zoom in") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()

plot1
plot2
```

## Percentage of ribosomal reads & cutoffs

```{r addRiboPercentage}
SO[["percent.ribo"]] <- PercentageFeatureSet(SO, pattern="^Rp[sl]")   # SEE IF ANY MODIFICATION IS REQUIRED
```

```{r plot-ribo}
VlnPlot(SO, features = c("percent.ribo"), ncol = 3) +
  geom_hline(aes(yintercept = ribo.high), color="blue", size=1.5) +
  geom_hline(aes(yintercept = ribo.low), color="orange", size=1.5) +
    ggtitle("Ribosomal expression\npercentage") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()
```

## Read counts thresholds

```{r plot-countRNA, fig.align='default', out.width='50%'}
plot1 <- VlnPlot(SO, features = c("nCount_RNA"), ncol = 3) +
  geom_hline(aes(yintercept = max.counts), color="purple", size=1.5) +
    geom_hline(aes(yintercept = min.counts), color="green", size=1.5) +
    ggtitle("Read counts per cell") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()
  
plot2 <- VlnPlot(SO, features = c("nCount_RNA"), ncol = 3) +
  geom_hline(aes(yintercept = max.counts), color="purple", size=1.5) +
  geom_hline(aes(yintercept = min.counts), color="green", size=1.5) +
    ylim(0, 25000) +
    ggtitle("Read counts per cell\nzoom in") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()

plot1
plot2
```

## Diversity of detected features per cell

```{r plot-featureRNA}
VlnPlot(SO, features = c("nFeature_RNA"), ncol = 3) +
    geom_hline(aes(yintercept = min.feat), color="#56B4E9", size=1.5) +
    ggtitle("Number of detected features\nper cell") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()
```

## Repartition of detected features

Features that are detected in less than `r min.cells` will be removed.

```{r plot-geneRepartition}
# Create dataframe
df <- data.frame(rowSums(SO@assays$RNA@counts != 0))
df$features <- rownames(df)
colnames(df) <- c('Nbr_of_cells', 'features')
rownames(df) <- NULL

## Plot gene expression repartition
ggplot(df, aes(x = Nbr_of_cells)) +
  geom_histogram() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20)) +
  ylab('frequency') +
  scale_x_continuous(trans = "log10") +
  expand_limits(x=c(0,10500), y=c(0,2000)) +
  geom_vline(aes(xintercept = min.cells), color="green", size=1) +
  ggtitle(paste0("Repartition of expressed features\n", dataset))
```

GET THE NUMBER OF REMOVED FEATURES

## Quality control application

```{r plot-filtering}
ggplot(SO@meta.data, aes(nCount_RNA, nFeature_RNA, colour = percent.mt)) +
  geom_point() +
  lims(colour = c(0, mito.high)) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20)) +
  ylab('nFeature_RNA') +
  geom_hline(aes(yintercept = min.counts), color="#56B4E9", size=1) +
  geom_vline(aes(xintercept = max.counts), color="purple", size=1) +
  geom_vline(aes(xintercept = min.feat), color="green", size=1) +
  ggtitle(paste0("Nb of features as function of Nb of counts\n", SO@project.name))
```

```{r filterQC}
SO <- subset(SO,
             features=which(df$Nbr_of_cells > min.cells),
             subset = percent.mt > mito.low & percent.mt < mito.high & nCount_RNA > min.counts & nCount_RNA < max.counts & nFeature_RNA > min.feat)
```

```{r size-QCfiltering}
size_track2 <- data.frame(cbind(
    t(dim(SO)),
    "QC filtering",
    "02"
))
colnames(size_track2) <- c('Nbr_of_features', 'Nbr_of_cells', 'Analysis_step_name', 'Step_number')
size_track2$Nbr_of_cells <- as.integer(as.character(size_track2$Nbr_of_cells))
size_track2$Nbr_of_features <- as.integer(as.character(size_track2$Nbr_of_features))
```

```{r plot-evolution1}
ggplot(rbind(size_track1, size_track2), aes(x = Analysis_step_name, y = Nbr_of_cells)) +
  geom_col(aes(color = Analysis_step_name, fill = Analysis_step_name), position = position_dodge(), width = 0.6) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20),
        axis.title.x = element_blank()) +
  scale_x_discrete(labels = label_wrap(6)) +
  ggtitle("Number of cells in each sub-dataset\nafter QC") +
    NoLegend()
```

```{r garbage-collec1, include = FALSE}
gc()
```

# Preprocessing workflow before doublet removal

```{r normalization1}
SO <- NormalizeData(SO, normalization.method = norm.meth, verbose=FALSE)
```

```{r show-slots}
data.frame(GetAssayData(SO, slot = "counts")[1:5,1:5]) %>%
  knitr::kable(caption = "Raw counts in 'counts' slot") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "800px", height = "300px")
data.frame(GetAssayData(SO, slot = "data")[1:5,1:5]) %>%
  knitr::kable(caption = "Normalized counts in 'data' slot") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "800px", height = "300px")
```

```{r hvg-vst1, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp"}
SO <- FindVariableFeatures(SO, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
```

```{r hvg-mvp1, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
SO <- FindVariableFeatures(SO, selection.method = hvg.meth, verbose=FALSE)
```

```{r show-HVGnum1, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
t(as.data.frame(table(SO@assays[["RNA"]]@meta.features$mvp.variable))) %>%
  knitr::kable(caption = "Number of features selected as highly variable genes (HVG)",
               row.names = FALSE,
               escape = F,
               align = "cc") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r scale1}
SO <- ScaleData(SO, features=rownames(SO), verbose=FALSE)
```

```{r runPCA1}
SO <- RunPCA(SO, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r plot-elbow1}
ElbowPlot(SO, ndims = pca.npcs) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color="purple", size=1) +
  ggtitle(paste0(SO@project.name, "\nElbowPlot"))        
```

```{r clustering1}
resolutions <- seq(0.6, 1.6, 0.2)
SO <- FindNeighbors(SO, dims = 1:top.pcs, verbose=FALSE)
SO <- FindClusters(SO, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
```

```{r runUMAP1}
SO <- RunUMAP(SO, dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE)
```
ls

```{r plot-clusters-1, fig.align='default', fig.show='hold'}
for (ares in resolutions){
    clusterResName <- grep(paste0("RNA_snn_res.", ares, "$"), colnames(SO@meta.data), value = TRUE)
    dimplotMetadata(SO, clusterResName, title = paste0(dataset, " : clusters at resolution ", ares)) 
    
    Sys.sleep(0.5)
}
```

```{r save1}
saveRDS(SO, file=file.path(rdsObjects, paste0("01_standardWF_", dataset, ".rds")))
```

- - -

\clearpage

```{r setup3, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart1}
SO <- readRDS(file.path(rdsObjects, paste0("01_standardWF_", dataset, ".rds")))
```

```{r setup4, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

# Doublets identification and removal

## Parameters set up

### Heterotypic doublets estimation

#### Cell annotation

```{r load-classifier}
scmap_classifier <- readRDS(file.path(classifier.folder, "scmap_classifier_1000markers.rds"))
ref_stages <- c("E6.5", "E6.75", "E7.0", "E7.25", "E7.5", "E7.75", "E8.0", "E8.25", "E8.5")
```


```{r classifier-transfert}
set.seed(general.seed)

# create the corresponding SingleCellExperiment object
sce <- as.SingleCellExperiment(x=SO)
rowData(sce)$feature_symbol <- rownames(sce)
counts(sce) <- as.matrix(counts(sce))
logcounts(sce) <- as.matrix(logcounts(sce))

# apply scmapCluster
scmapCluster_results <- scmapCluster(projection=sce, index_list=scmap_classifier[ref_stages], threshold=0)

# add the celltype from the in vivo atlas to the Seurat object
SO <- AddMetaData(object=SO, metadata=scmapCluster_results$combined_labs, col.name="celltype_DF")
```


```{r plot-DF-celltype}
rm(sce)
gc()

dimplotMetadata(SO, "celltype_DF")
```


#### Number of cells to label as doublet (ie. heterotypic doublets)

```{r homotypic-proportion}
# based on annotation (celltype from pijuansala classifier)
# could be also the louvain clusters determined from the preprocessus step
annotations <- SO@meta.data$celltype_DF
homotypic.prop <- modelHomotypic(annotations)
```

```{r heterotypic-estimation}
# based on annotation (celltype from pijuansala classifier)
# could be also the louvain clusters determined from the preprocessus step
nDoublets <- round(ncol(SO)*dblt.rate/100)
nDoublets_nonhomo <- round(nDoublets*(1-homotypic.prop))
```

### Neighborhood size optimization

```{r generate-pKs, results='hide', fig.show='hide'}
sweep.res <- paramSweep_v3(SO, PCs = 1:top.pcs) # as estimated from PC elbowPlot
sweep.stats_SO <- summarizeSweep(sweep.res, GT = FALSE)
Sys.sleep(0.5)
bcmvn_SO <- find.pK(sweep.stats_SO)
```

```{r optimize-pK, out.width='50%'}
ggplot(bcmvn_SO, aes(pK, BCmetric, group = 1)) +
  geom_point() +
  geom_line()

pK <- bcmvn_SO %>% # select the pK that corresponds to max bcmvn to optimize doublet detection
  filter(BCmetric == max(BCmetric)) %>%
  select(pK) 
pK <- as.numeric(as.character(pK[[1]]))
```

## Doublets identification - DoubletFinder run

```{r runDF}
SO <- doubletFinder_v3(SO, 
                       PCs = 1:top.pcs, 
                       pN = 0.25,
                       pK = pK, 
                       nExp = nDoublets_nonhomo)
```

```{r plot-doublets}
# remove the cells identified as doublets of each of the sub-datasets
col_dblts <- grep("DF.classifications", colnames(SO@meta.data), value=TRUE)

dimplotMetadata(SO, col_dblts, title = paste0(dataset, " : doublets prediction"))
```

```{r df-count-celltypeDF}
Idents(SO) <- col_dblts
celltypeDF <- as.data.frame.matrix(table(Idents(SO), SO@meta.data$celltype_DF))

celltypeDF %>%
  knitr::kable(caption = "Doublet ratio over celltypes got from -- ") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")
```

```{r df-count-cluster}
clustersRes <- grep(paste0("res.", res, "$"), colnames(SO@meta.data), value=TRUE)
clusterDF <- as.data.frame.matrix(table(Idents(SO), SO@meta.data[,which(colnames(SO@meta.data) == clustersRes)])) 

clusterDF %>%
  knitr::kable(caption = paste0("Doublet ratio over clusters at resolution ", res)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")
```

## Subset to singlets

```{r remove-doublets}
SOsing <- subset(SO, idents='Singlet')

# remove useless columns
SOsing@meta.data[[grep("DF.classifications", colnames(SOsing@meta.data))]] <- NULL
names(SOsing@meta.data)[names(SOsing@meta.data) == grep("pANN", colnames(SOsing@meta.data), value=T)] <- "pANN"
```

```{r size-singlets}
size_track3 <- data.frame(cbind(
    t(dim(SOsing)),
    "Removed doublets",
    "03"
))
colnames(size_track3) <- c('Nbr_of_features', 'Nbr_of_cells', 'Analysis_step_name', 'Step_number')
size_track3$Nbr_of_cells <- as.integer(as.character(size_track3$Nbr_of_cells))
size_track3$Nbr_of_features <- as.integer(as.character(size_track3$Nbr_of_features))
```

```{r plot-evolution2}
ggplot(rbind(size_track1, size_track2, size_track3), aes(x = Analysis_step_name, y = Nbr_of_cells)) +
  geom_col(aes(color = Analysis_step_name, fill = Analysis_step_name), position = position_dodge(), width = 0.6) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20)) +
  scale_x_discrete(labels = label_wrap(6)) +
  ggtitle("Evolution of the number of cells")
```

```{r save2}
saveRDS(SOsing, file=file.path(rdsObjects, paste0("02_removedDoublets_", dataset, ".rds")))
```

```{r garbage-collec2, include=FALSE}
rm(SO)
gc()
```

```{r setup5, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart2}
SOsing <- readRDS(file.path(rdsObjects, paste0("02_removedDoublets_", dataset, ".rds")))
```

```{r setup6, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

# Preprocessing workflow after doublets removal

```{r hvg-vst2, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp"}
SOsing <- FindVariableFeatures(SOsing, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
```

```{r hvg-mvp2, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
SOsing <- FindVariableFeatures(SOsing, selection.method = hvg.meth, verbose=FALSE)
head(SOsing@assays[["RNA"]]@meta.features) %>%
  knitr::kable(caption = "Example of HVG selection output") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
 
```{r show-HVGnum2, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
t(as.data.frame(table(SOsing@assays[["RNA"]]@meta.features$mvp.variable))) %>%
  knitr::kable(caption = "Number of features selected as highly variable genes (HVG)",
               row.names = FALSE,
               escape = F,
               align = "cc") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```
 
 
```{r save3-varFeat-dataset}
var.feats.dataset <- VariableFeatures(SOsing)
saveRDS(var.feats.dataset, file=file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds")))
```

```{r scale2, eval=do.scale, echo=do.scale}
SOsing <- ScaleData(SOsing, features=rownames(SOsing), verbose=FALSE)
```

```{r copy-dataSlot2, eval=!do.scale, echo=!do.scale}
SOsing <- SetAssayData(SOsing, assay = "RNA", slot = "scale.data", new.data = as.matrix(SOsing@assays$RNA@data))
```

```{r runPCA2}
SOsing <- RunPCA(SOsing, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r plot-elbow2}
ElbowPlot(SOsing, ndims = pca.npcs) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color="purple", size=1) +
  ggtitle(paste0(SOsing@project.name, "\nElbowPlot"))        
```

```{r clustering2}
SOsing@meta.data[grep("RNA_snn", names(SOsing@meta.data))] <- NULL
resolutions <- seq(0.6, 1.6, 0.1)
SOsing <- FindNeighbors(SOsing, dims = 1:top.pcs, verbose=FALSE)
SOsing <- FindClusters(SOsing, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
```

```{r runUMAP2}
SOsing <- RunUMAP(SOsing, dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE)
```

```{r plot-clusters-2}
for (ares in resolutions){
    clusterResName <- grep(paste0("RNA_snn_res.", ares, "$"), colnames(SOsing@meta.data), value = TRUE)
    dimplotMetadata(SOsing, clusterResName, title = paste0(dataset, " : clusters at resolution ", ares)) 
    
    Sys.sleep(0.5)
}
```

```{r save4}
saveRDS(SOsing, file=file.path(rdsObjects, paste0("03_WF_onSinglets_", dataset, ".rds")))
```

```{r setup7, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart3}
SOsing <- readRDS(file.path(rdsObjects, paste0("03_WF_onSinglets_", dataset, ".rds")))
```

```{r setup8, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

```{r garbage-collec3, include=FALSE}
gc()
```

- - -

\clearpage

# Learning transfert from an Atlas

## Atlas preparation

```{r atlasLoading}
atlas.metadata <- read.table(file.path(atlas.folder, "meta.tab") , sep="\t" , header=TRUE )
atlas.genes <- read.csv(file.path(atlas.folder, "genes.tsv"), sep="\t", header = FALSE, as.is = TRUE)
atlas.data <- readMM(file.path(atlas.folder, "raw_counts.mtx"))
atlas.data@Dimnames[[2]] <- atlas.metadata$cell
atlas.data@Dimnames[[1]] <- atlas.genes$V2
```

```{r garbage-collec4, include=FALSE}
rm(atlas.genes)
gc()
```

```{r atlasStandardProcess}
atlas <- CreateSeuratObject(counts = atlas.data, project = "Atlas", min.cells=min.cells, min.features = min.feat)
rm(atlas.data)
gc()

nonFiltered <- intersect(colnames(atlas), atlas.metadata$cell)
atlas.metadata <- atlas.metadata[which(atlas.metadata$cell %in% nonFiltered),]

atlas <- NormalizeData(atlas, normalization.method = norm.meth, verbose=FALSE)
atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$stage, col.name = "day")
atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$celltype, col.name = "celltype")
atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$sequencing.batch, col.name = "replicate")
#atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$sequencing.batch+10, col.name = "Replicate")
atlas <- AddMetaData(object = atlas, metadata = paste(atlas$day, "_batch_0", atlas$replicate, sep=""), col.name = "dataset")
atlas$model <- "Embryo"
atlas[["percent.mt"]] <- PercentageFeatureSet(atlas, pattern="^mt-")
atlas[["percent.ribo"]] <- PercentageFeatureSet(atlas, pattern="^Rp[sl]")
```

```{r garbage-collec5, include=FALSE}
rm(atlas.metadata)
gc()
```

```{r atlas_subsetting}
Idents(atlas) <- atlas$day
atlas.subset <- subset(x = atlas, idents = c("mixed_gastrulation"), invert=T)

Idents(atlas.subset) <- atlas.subset$celltype
atlas.subset <- subset(x = atlas.subset, cells = colnames(atlas.subset)[is.na(Idents(atlas.subset))], invert = T)
atlas.subset <- subset(atlas.subset, idents=unique(grep("ExE", atlas.subset$celltype, value = T)), invert=T)
atlas.subset <- subset(atlas.subset, idents="Parietal endoderm", invert=T)
```

```{r garbage-collec6, include=FALSE}
rm(atlas)
gc()
```

## Integrate analyzed data with the Atlas {.tabset .tabset-pills .tabset-fade}

```{r hvg-vst-atlas, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp"}
atlas.subset <- FindVariableFeatures(atlas.subset, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
saveRDS(atlas.subset, file.path(rdsObjects, paste0("XX_atlas_before_integ_with_", dataset, ".rds")))
```

```{r hvg-mvp-atlas, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp", results='asis'}
atlas.subset <- FindVariableFeatures(atlas.subset, selection.method = hvg.meth, verbose=FALSE)
saveRDS(atlas.subset, file.path(rdsObjects, paste0("XX_atlas_before_integ_with_", dataset, ".rds")))
```

```{r show-HVGnum-atlas, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
t(as.data.frame(table(atlas.subset@assays[["RNA"]]@meta.features$mvp.variable))) %>%
  knitr::kable(caption = "Number of features selected as highly variable genes (HVG)",
               row.names = FALSE,
               escape = F,
               align = "cc") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r integration-with-atlas}
features <- SelectIntegrationFeatures(object.list = list(SOsing, atlas.subset))
anchors <- FindIntegrationAnchors(object.list = list(SOsing, atlas.subset), anchor.features = features)
SO.align <- IntegrateData(anchorset = anchors)

SO.align@project.name <- paste0(dataset, "_with_atlas")
DefaultAssay(SO.align) <- "integrated"
```

```{r scale-aligned, eval=do.scale, echo=do.scale}
# Run the standard workflow for visualization and clustering
SO.align <- ScaleData(SO.align, assay = DefaultAssay(SO.align), verbose = FALSE)
```

```{r copy-dataSlot-aligned, eval=!do.scale, echo=!do.scale}
SO.align <- SetAssayData(SO.align, assay = DefaultAssay(SO.align), slot = "scale.data", new.data = as.matrix(SO.align@assays[[DefaultAssay(SO.align)]]@data))
```

```{r dimReduction-aligned}
SO.align <- RunPCA(SO.align, npcs = pca.npcs, verbose = FALSE)
ElbowPlot(SO.align, ndims = pca.npcs)
```

```{r show-alignedUMAP}
SO.align <- RunUMAP(SO.align, reduction = "pca", dims = 1:10)
dimplotMetadata(SO.align, metadata = "model", title = "Gastruloid and atlas cells\nin a shared UMAP embedding")
```

### Cell identity transfert {.bs-callout .bs-callout-orange}

#### Create a centroid table on Atlas cell types in pca space

```{r classifierCreation}
Idents(SO.align) <- SO.align$model
cells.tmp <- WhichCells(SO.align, idents = "Embryo")
tmp <- SO.align@reductions$pca@cell.embeddings[cells.tmp, 1:top.pcs]
idents.tmp <- SO.align$celltype[cells.tmp]
centroids <- data.frame(row.names = unique(idents.tmp))
for(i in rownames(centroids)){
  for(j in colnames(tmp)){
    centroids[i,j] <- mean(tmp[idents.tmp==i,j])
  }
}
```

#### Apply that knowledge using scmap concept to analyzed data

```{r classifierApplication}
Idents(SO.align) <- SO.align$model
cells.tmp <- WhichCells(SO.align,idents = "Gastruloids")
tmp <- SO.align@reductions$pca@cell.embeddings[cells.tmp, 1:top.pcs]
idents.tmp <- SO.align$celltype[cells.tmp]
idents.tmp[] <- ""
dist <- list()
for(i in names(idents.tmp)){
  for(j in rownames(centroids)){
    dist[[j]] <- cor(x = as.numeric(tmp[i,]),y = as.numeric(centroids[j,]),method = "pearson")
  }
  idents.tmp[i] <- names(which.max(dist))
}

SO.align$orig.celltype <- SO.align$celltype
SO.align$aligned.celltype <- SO.align$celltype
SO.align$aligned.celltype[cells.tmp] <- idents.tmp
SO.align$celltype <- SO.align$aligned.celltype
SO.align$aligned.celltype <- NULL

Idents(SO.align) <- SO.align$celltype
```

```{r save5}
saveRDS(SO.align, file=file.path(rdsObjects, paste0("04_celltypeFromAtlas_", SO.align@project.name, ".rds")))
```

```{r garbage-collec7, include=FALSE}
rm(centroids, cells.tmp, tmp, idents.tmp, dist)
gc()
```

```{r show-celltypeSOalign}
dimplotMetadata(SO.align, metadata = "celltype", title = "Celltypes on the combined object\nGastruloids and atlas cells")
```

```{r setup9, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart4}
SO.align <- readRDS(file.path(rdsObjects, paste0("04_celltypeFromAtlas_", dataset,"_with_atlas.rds")))
atlas.subset <- readRDS(file.path(rdsObjects, paste0("XX_atlas_before_integ_with_", dataset, ".rds")))
var.feats.dataset <- readRDS(file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds")))
```

```{r setup10, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```


### Global orientation of the UMAP plots {.bs-callout .bs-callout-orange}

#### Atlas data preprocessing steps (ScaleData, RunPCA)

```{r scale-atlas, eval=do.scale, echo=do.scale}
# Run the standard workflow for visualization and clustering
atlas.subset <- atlas.subset(SO.align, assay = DefaultAssay(atlas.subset), verbose = FALSE)
```

```{r copy-dataSlot-atlas, eval=!do.scale, echo=!do.scale}
atlas.subset <- SetAssayData(atlas.subset, assay = DefaultAssay(atlas.subset), slot = "scale.data", new.data = as.matrix(atlas.subset@assays$RNA@data[VariableFeatures(atlas.subset),]))
```

```{r runPCA-atlas}
atlas.subset <- RunPCA(atlas.subset, reduction.name = "PCAown", reduction.key = "PCown_", verbose = FALSE)
ElbowPlot(atlas.subset, ndims = pca.npcs, reduction = "PCAown")
```

```{r garbage-collec8, include=FALSE}
gc()
```

#### Get UMAP of a subset of the Atlas data

```{r atlas_refLayout}
spread <- 2
min_dist <- 1
Idents(atlas.subset) <- 'celltype'

# Downsample the number of cells per identity class
set.seed(general.seed)
cells.use <- WhichCells(object = atlas.subset, downsample = 200) #colnames(atlas.subset) #sample(colnames(atlas.subset),1000)
nn=300
local_connectivity=1 # Tried 2 and was not so convincing. Should not be more than the local intrinsic dimension of the manifold.
fast_sgd <- F # Should set it to FALSE ultimately, to get exactly reproducible results, but TRUE can be useful as it is faster for early exploration.
umap_init <- "spectral" # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates.
reduction.use <- "PCAown"

set.seed(general.seed)
tmp <- umap(X = Embeddings(atlas.subset[[reduction.use]])[cells.use, 1:10],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T,
            verbose = F)
tmp2 <- 0*Embeddings(atlas.subset[[reduction.use]])[,1:3]
tmp2[cells.use,] <- tmp$embedding
atlas.subset[["umap200"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP200_")
```

UMAP dimension reduction on atlas, with 200 cells per celltype, 300 neighbors

```{r plot-atlasUMAP-200}
dimplotMetadata(atlas.subset, "celltype",
                title = paste0(dataset, " : atlas celltypes\nvisualization reduced to 200 cells per celltype"),
                reduction = "umap200")
```

```{r save-atlasUMAP-200}
saveRDS(atlas.subset, file=file.path(rdsObjects, paste0("05_UMAP_atlas_subset200cells_", dataset, ".rds")))
```

#### Create a centroid table on Atlas cell types in UMAP200 space

```{r atlas_cluster_avg.pos}
Idents(atlas.subset) <- atlas.subset$celltype
x_ref <- data.frame(row.names = unique(atlas.subset$celltype))
for(i in unique(atlas.subset$celltype)){
  x_ref[i,1] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),1])
  x_ref[i,2] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),2])
  x_ref[i,3] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),3])
}
```

#### Create random initial coordinates for the integrated object of Atlas and analyzed data

```{r UMAPinit_sharedLayout}
min_dist <- 8
spread <- 25
nn <- 300

# Generate a random position around the layout defined positions for all cells according to their cell types:
noise <- 5
set.seed(general.seed)
x_ini <- data.frame(row.names = colnames(SO.align))
x_ini[,1] <- runif(length(colnames(SO.align)))*noise
x_ini[,2] <- runif(length(colnames(SO.align)))*noise
x_ini[,3] <- runif(length(colnames(SO.align)))*noise
Idents(SO.align) <- SO.align$celltype
for(i in unique(SO.align$celltype)){
  if(i %in% rownames(x_ref)){
    x_ini[WhichCells(SO.align,idents=i),1] <- x_ini[WhichCells(SO.align,idents=i),1]+x_ref[i,1]
    x_ini[WhichCells(SO.align,idents=i),2] <- x_ini[WhichCells(SO.align,idents=i),2]+x_ref[i,2]
    x_ini[WhichCells(SO.align,idents=i),3] <- x_ini[WhichCells(SO.align,idents=i),3]+x_ref[i,3]
  }
}
```

```{r garbage-collec9, include=FALSE}
gc()
```

#### Compute UMAP dimension reduction on the integrated object, nested by the random initial coordinates

```{r apply_UMAPshared}
cells.use <- colnames(SO.align) #WhichCells(object = tmp,downsample = 300) #colnames(SO) #sample(colnames(SO),1000)

local_connectivity=1 # Should not be more than the local intrinsic dimension of the manifold. I would have imagined 2-3 could be reasonable, but doesn't give good results. 
fast_sgd <- T # Should set it to false ultimately, to get exactly reproducible results, but can use T to get faster for early exploration. 
umap_init <- as.matrix(x_ini[cells.use,]) # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates. 

set.seed(general.seed)
reduction.use <- "pca"
tmp <- umap(X = Embeddings(SO.align[[reduction.use]])[cells.use, 1:10],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T, 
            verbose = F)
tmp2 <- 0*Embeddings(SO.align[[reduction.use]])[,1:3]
tmp2[cells.use,] <- tmp$embedding
SO.align[["umapShared3d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAPshared3d_", assay = DefaultAssay(SO.align))


umap_init <- as.matrix(x_ini[cells.use, 1:2]) # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates. 

set.seed(general.seed)
reduction.use <- "pca"
tmp <- umap(X = Embeddings(SO.align[[reduction.use]])[cells.use, 1:10],
            init = umap_init,
            n_neighbors = nn,
            n_components = 2,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T, 
            verbose = F)
tmp2 <- 0*Embeddings(SO.align[[reduction.use]])[,1:2]
tmp2[cells.use,] <- tmp$embedding
SO.align[["umapShared2d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAPshared2d_", assay = DefaultAssay(SO.align))
```

```{r save6}
saveRDS(SO.align, file=file.path(rdsObjects, paste0("05_UMAP_shared_", SO.align@project.name, ".rds")))
```

```{r garbage-collec10, include=FALSE}
rm(tmp, tmp2, cells.use, x_ref, x_ini)
gc()
```

```{r setup11, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart5}
SO.align <- readRDS(file.path(rdsObjects, paste0("05_UMAP_shared_", dataset, "_with_atlas.rds")))
var.feats.dataset <- readRDS(file=file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds")))
```

```{r setup12, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

# `r dataset` data analysis after label transfert and initialized UMAP coordinates

```{r extract-dataset}
cells.use <- colnames(SO.align)[SO.align$model=="Gastruloids"]
SO <- SO.align[,cells.use]
SO@project.name <- dataset
```

```{r set-DefaultAssay}
DefaultAssay(SO) <- "RNA"
```

## Analyzed data preprocessing

```{r set-HVG}
VariableFeatures(SO) <- var.feats.dataset
```

```{r scale3, eval=do.scale, echo=do.scale}
SO <- ScaleData(SO, features=rownames(SO), verbose=FALSE)
```

```{r copy-dataSlot3, eval=!do.scale, echo=!do.scale}
SO <- SetAssayData(SO, assay = "RNA", slot = "scale.data", new.data = as.matrix(SO@assays$RNA@data))
```

```{r runPCA3}
SO <- RunPCA(SO, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r plot-elbow3}
ElbowPlot(SO, ndims = pca.npcs) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color="purple", size=1) +
  ggtitle(paste0(SO@project.name, "\nElbowPlot"))        
```

## Run UMAP algorithm, nested on atlas coordinates

```{r UMAP-dataset}
# Create 3-dimensional UMAP coordinates
SO[["umapShared3d"]] <- CreateDimReducObject(embeddings = Embeddings(SO.align$umapShared3d)[cells.use,], key = "UMAPshared3d_", assay = DefaultAssay(SO))

init_sdev <- 1e-4
noise_level <- 0
min_dist <- 6
spread <- 15
nn <- 300

umap_init <- as.matrix(Embeddings(SO[["umapShared3d"]]))
set.seed(general.seed)
umap_init <- umap_init + cbind(rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level))
set.seed(general.seed)
reduction.use <- "pca" # pca1 or harmony
tmp <- umap(X = Embeddings(SO[[reduction.use]])[colnames(SO), 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            local_connectivity=1,
            ret_model=T,
            verbose = F,
            n_epochs = 1000,
            learning_rate = 1,
            init_sdev = init_sdev)

tmp2 <- 0*Embeddings(SO[["pca"]])[,1:3]
tmp2[colnames(SO),] <- tmp$embedding
SO[["umap3d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP3d_", assay = DefaultAssay(SO))

# Create 2-dimensional UMAP coordinates
SO[["umapShared2d"]] <- CreateDimReducObject(embeddings = Embeddings(SO.align$umapShared2d)[cells.use,], key = "UMAPshared2d_", assay = DefaultAssay(SO))

umap_init <- as.matrix(Embeddings(SO[["umapShared2d"]]))
set.seed(general.seed)
umap_init <- umap_init + cbind(rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level))
set.seed(general.seed)
reduction.use <- "pca" # pca1 or harmony
tmp <- umap(X = Embeddings(SO[[reduction.use]])[colnames(SO), 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 2,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            local_connectivity=1,
            ret_model=T,
            verbose = F,
            n_epochs = 1000,
            learning_rate = 1,
            init_sdev = init_sdev)

tmp2 <- 0*Embeddings(SO[["pca"]])[,1:2]
tmp2[colnames(SO),] <- tmp$embedding
SO[["umap2d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP2d_", assay = DefaultAssay(SO))
```

```{r save7}
saveRDS(SO, file=file.path(rdsObjects, paste0("06_umap_2d3d_", SO@project.name, ".rds")))
```

```{r garbage-collec11, include=FALSE}
rm(umap_init, tmp, tmp2)
gc()
```

```{r show-umap2d}
dimplotMetadata(SO, "celltype",
                title = paste0("Gastruloid cells in UMAP embbeding\nnested on atlas UMAP coordinates"),
                reduction = "umap2d")
```

```{r setup13, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart6}
SO <- readRDS(file.path(rdsObjects, paste0("06_umap_2d3d_", SO@project.name, ".rds")))
```

```{r setup14, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

## Clustering (FindNeighbors, FindClusters)

```{r clustering3}
resolutions <- seq(0.6, 1.6, 0.1)
SO <- FindNeighbors(SO, dims = 1:top.pcs, verbose=FALSE)
SO <- FindClusters(SO, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
```

```{r save8}
saveRDS(SO, file=file.path(rdsObjects, paste0("06_clusters_", SO@project.name, ".rds")))
```

```{r garbage-collec12, include=FALSE}
gc()
```

```{r show-clustering}
selectedRes <- grep(paste0(DefaultAssay(SO), ".*res.", res, "$"), colnames(SO@meta.data), value=TRUE)
Idents(SO) <- SO@meta.data[[selectedRes]]
dimplotMetadata(SO, selectedRes,
                reduction = "umap2d")
```

```{r setup15, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart7}
SO <- readRDS(file.path(rdsObjects, paste0("06_clusters_", dataset, ".rds")))
```

```{r setup16, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

## Differential expression analysis

```{r selected-resolution}
#SO$seurat_clusters <- NULL
selectedRes <- grep(paste0(DefaultAssay(SO), ".*res.", res, "$"), colnames(SO@meta.data), value=TRUE)
SO$clusters <- SO[[selectedRes]]
Idents(SO) <- SO$clusters
```

```{r findAllMarkers}
DefaultAssay(SO) <- 'RNA'

markers <- FindAllMarkers(SO)
#markers.sign <- markers[markers$p_val_adj < 0.001 & markers$avg_logFC > log(1.5), ]
markers.sign <- markers[order(-markers$avg_log2FC), ]
markers.sign <- markers.sign[order(markers.sign$cluster), ]
markers.sign <- markers.sign[ , c(6, 7, 2:4, 1, 5)]
write.table(x = markers.sign, file = file.path(dataset.anFolder,
						paste0("markers_min.pct_logFC_default_", 
                                            dataset, ".integ.res_", selectedRes, ".csv")), sep = ",", row.names = F, col.names = T)
```

```{r topNmarkers}
topNmarkers <- extract_topn(markers.sign, topn = top.markers)

domCelltypes <- add_dominantMetadata(SO, metadata = "celltype")
topNmarkers <- left_join(topNmarkers, domCelltypes, by='cluster')
```

```{r addDay_dominantMetadata, eval=(do.integ || do.merge), echo=(do.integ || do.merge)}
domDays <- add_dominantMetadata(SO, metadata = "day")
topNmarkers <- left_join(topNmarkers, domDays, by='cluster')
```

```{r saveTopNmarkers}
write.table(x = topNmarkers, file = file.path(dataset.anFolder, paste0("top", top.markers, "markers.csv")), sep = ",", row.names = F, col.names = T)
```

```{r diplayTable}
datatable(topNmarkers, rownames = FALSE, filter = "top", options = list(pageLength = 5, scrollX=T))
```




