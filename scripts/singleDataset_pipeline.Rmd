---
author: "Céline Chevalier, Anaïs Baudot, Fabienne Lescroart, Laurent Argiro, Stéphane Zaffran"
date: "Last compiled on `r format(Sys.time(), '%d %B, %Y')`"
output:
    html_document:
        theme:
            bootswatch: yeti
        toc: yes
        toc_float:
          collapsed: false
          smooth_scroll: true
        number_sections: yes
        df_print: kable
        code_folding: hide
    pdf_document:
        number_sections: yes
        toc: yes
        toc_depth: 3
        keep_tex: no
params:
    analysis.name:
        value: "analysis_"
    new.analysis:
        value: FALSE
    dataset:
        value: NA
        choices: [lab_day_04, lab_day_05, lab_day_05bis, lab_day_06, lab_day_11]
    do.integ:
        value: FALSE
    do.merge:
        value: FALSE
    mito.low:
        value: 1.5
        min: 0
        max: 99
    mito.high:
        value: 10
        min: 1
        max: 100
    ribo.low:
        value: 25
        min: 0
        max: 99
    ribo.high:
        value: 45
        min: 1
        max: 100
    min.feat:
        value: 200
    min.cells:
        value: 3
    min.counts:
        value: 1500
    max.counts:
        value: 150000
    norm.meth:
        value: "LogNormalize"
    hvg.meth:
        value: mvp
        choices: [vst, mvp, disp]
    hvg.num:
        value: FALSE
    do.scale:
        value: FALSE
    pca.npcs:
        value: 30
    pca.print:
        value: 10
    top.pcs:
        value: 15
    dblt.rate:
        value: 8
    res:
        value: 1.0
    algo.cluster:
        value: 4
        choices: [1, 2, 3, 4]
    top.markers:
        value: 20
    general.seed: 17
title: |
  | Protocole 1:
  | single scRNAseq data analysis
  | `r params$dataset`
---

```{r setup1, eval=TRUE, include=FALSE}
options(knitr.purl.inline = TRUE)
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,

    # text output
    echo = TRUE,
    results = 'hold',
    warning = FALSE,
    error = FALSE,
    message = FALSE,
    strip.white = TRUE,

    # code decoration
    #tidy = TRUE,
    tidy.opts = list(width.cutoff = 90),
    comment = '',
    attr.output='.numberLines',
    
    # plots
    #fig.path = "figure/",      # is set later, in chunk setup2
    fig.show = "asis",         # tuned to "hold" in multiple plots chunk
    dev = c('png', 'pdf'),
    fig.width = 12,
    fig.height = 12,
    #fig.asp=1.3               # fig.height = fig.width * fig.asp
    #out.extra = 'style="border:5px solid orange;"'     # orange box arround plots
    fig.align = "center"       # should be tuned to default in multiple plots chunk
)
```

```{r load-lib, include=FALSE}
library(dplyr)
library(Matrix)
library(Seurat)
library(ggplot2)
library(reticulate)
library(scmap)
library(RColorBrewer)
library(DoubletFinder)
library(stringr)
library(kableExtra)
library(formattable)
library(knitr)
library(SingleCellExperiment)
library(BiocGenerics)
library(scales)
library(formatR)
library(uwot)
library(DT)
library(patchwork)
```

```{r get-params, include=FALSE}
bindingIsLocked("params", env = .GlobalEnv)
unlockBinding("params", env = .GlobalEnv)
attach(params)
```

```{r sourceCodes}
source("./utilities/dimplotMetadata.R")
source("./utilities/extract_topn.R")
source("./utilities/add_dominantMetadata.R")
source("./utilities/additionalPlots.R")
source("./utilities/00_generalDeps.R")
#source("/mnt/DATA_4TB/projects/XX/analysis/seuratAnalysis/scripts/lionel_codes/FeatureViolinplot.R")
#source("/mnt/DATA_4TB/projects/XX/analysis/seuratAnalysis/scripts/lionel_codes/Violin_dotplot.R")
```


# Global settings {.tabset .tabset-pills .tabset-fade}

## `r dataset` analysis settings

```{r show-params}
ul <- unlist(params)
df <- data.frame(keyName=names(ul), value=ul, row.names=NULL)
names(df) <- c('Parameters', 'Values')
df1 <- df[1:ceiling(dim(df)[1]/3),]
df1$Parameters <- cell_spec(df1$Parameters, bold = T)
df2 <- df[(ceiling(dim(df)[1]/3)+1):(2*ceiling(dim(df)[1]/3)),]
df2$Parameters <- cell_spec(df2$Parameters, bold = T)
df3 <- df[((2*ceiling(dim(df)[1]/3))+1):dim(df)[1],]
df3$Parameters <- cell_spec(df3$Parameters, bold = T)


list(df1, df2, df3) %>%
  knitr::kable(align = "ll", row.names = FALSE, escape = F) %>% 
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE)
rm(df)
```


## Directories

Set either input and output directories.

```{r base-path}
#basePath <- "/home/celine/temp2"
basePath <- "/mnt/DATA_4TB/projects/gastruloids_sc_Lescroart/analysis/seuratAnalysis" # local server
#basePath <- "/shared/projects/mothard_in_silico_modeling/seurat_analysis" # IFB server
```

### Input directories

Get the path of the inputs used for the analysis:

- mmgLab.data

- atlas.folder

- classifier.folder

- inputTables.folder

- otherInputs

```{r input-dirs}
inputs.folder <- file.path(basePath, "inputData")

mmgLab.data <- file.path(inputs.folder, "lab_data")
atlas.folder <- file.path(inputs.folder, "atlas")
classifier.folder <- file.path(inputs.folder, "scmap_pijuansala_classifier")
inputTables.folder <- file.path(inputs.folder, "InputTables")
otherInputs <- file.path(inputs.folder, "other")
```

### Output directories

Management of pre-existing ran analysis to output figures, tables and reports.

```{r anteriority, eval=!new.analysis, echo=!new.analysis}
last_analysis <- 0
dirs.in.dir <- list.dirs(basePath, full.names = FALSE, recursive = FALSE)
anterior <- analysis.name %in% dirs.in.dir
if (anterior){
    last_analysis <- max(as.numeric(str_extract_all(anterior, "\\d+", simplify = TRUE)), na.rm=T)
} else {
    params$new.analysis <- TRUE
    attach(params)
}
```

```{r default_analysisName_old, eval=(!new.analysis && analysis.name == "analysis_"), echo=(!new.analysis && analysis.name == "analysis_")}
analysis.name <- paste0(analysis.name, as.character(last_analysis))
```

```{r default_analysisName_new, eval=(new.analysis && analysis.name == "analysis_"), echo=(new.analysis && analysis.name == "analysis_")}
analysis.name <- paste0(analysis.name, as.character(last_analysis + 1))
```

```{r newAnalysis, eval=new.analysis, echo=new.analysis}
baseAnalysis <- file.path(basePath, analysis.name)
if(!dir.exists(baseAnalysis)){dir.create(baseAnalysis)}
rdsObjects <- file.path(baseAnalysis, "rdsObjects")
if(!dir.exists(rdsObjects)){dir.create(rdsObjects)}
print(baseAnalysis)
```

```{r reAnalysis, eval=!new.analysis, echo=!new.analysis}
baseAnalysis <- file.path(basePath, analysis.name)
rdsObjects <- file.path(baseAnalysis, "rdsObjects")
if(!dir.exists(rdsObjects)){dir.create(rdsObjects)}
```

```{r dataset-analysisFolder}
dataset.anFolder <- file.path(baseAnalysis, dataset)
if(!dir.exists(dataset.anFolder)){dir.create(dataset.anFolder)}
fig.folder <- file.path(dataset.anFolder, "figures/")
if(!dir.exists(fig.folder)){dir.create(fig.folder)}
```

```{r setup2, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    
    # figures
    fig.path = fig.folder
)
```

## Set up color vectors

Load table to in which colors are defined for the labels used in the analysis.

```{r load_colorTables}
colors.table <- read.table(file=file.path(inputTables.folder, "ClusterColors.tsv"), sep="\t", header=T, comment.char="", as.is=T)
colors.celltype <- setNames(colors.table$blind_friendly[!is.na(colors.table$transferred_identity)], colors.table$transferred_identity[!is.na(colors.table$transferred_identity)])

colors.stage <- setNames(c("#bb573b", "#ac9d3e", "#5aaf6a", "#7564b9", "#b94c84", "#ba4b7d", "#90b03d", "#60a756", "#45c097", "#5e8bd5", "#6d71d8", "#573585", "#bd80d5", "#b853a2", "#ba4b7d"), c("Day_04", "Day_05", "Day_06", "Day_07", "Day_10", "Day_11", "E6.5", "E6.75", "E7.0", "E7.25", "E7.5", "E7.75", "E8.0", "E8.25", "E8.5"))
```

```{r starter, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

# Get `r dataset` data

## Load the data

```{r single-load}
data.path <- file.path(mmgLab.data, dataset)
raw.data <- Read10X(data.dir = data.path, gene = 2)
SO <- CreateSeuratObject(counts=raw.data, project=dataset)
```

## Add and show metadata

```{r add-metaData}
day <- str_to_title(str_extract(dataset, 'day_[0-9]*$'))

SO <- AddMetaData(object = SO, metadata = day, col.name = "day")
SO <- AddMetaData(object = SO, metadata = dataset, col.name = "dataset")
replicateValue <- if (dataset == "lab_day_05bis") 1 else 0
SO <- AddMetaData(SO, metadata = replicateValue, col.name = 'replicate')
SO$model <- "Gastruloids"
```

```{r show-metaData}
data.frame(head(SO@meta.data)) %>%
  knitr::kable(align = "lrrrrrr",
               caption = paste0("First lines of ", dataset, " metadata table")) %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")
```

## Nomenclature for cell names

```{r renaming_cells}
cell_ids <- colnames(SO)
UMIs <- str_extract(cell_ids, '[A-Z]*')
cellnames <- paste(SO$dataset, SO$replicate, UMIs, sep = '_')

SO <- RenameCells(SO, new.names = cellnames)

head(colnames(SO), 4)
```

Below, we can see that there are as many unique cell identifiers as the number of cells.

Number of cells in the dataset: `r dim(SO)[2]`

Number of unique cell identifiers: `r length(unique(colnames(SO)))`


- - -

\clearpage

```{r initial-size, echo=FALSE}
size_track1 <- data.frame(cbind(
    t(dim(SO)),
    "Preliminary Counts",
    "01"
))

colnames(size_track1) <- c('Nbr_of_features', 'Nbr_of_cells', 'Analysis_step_name', 'Step_number')
```

# Quality control

## Percentage of mitochondrial reads & cutoffs

```{r addMitoPercentage}
SO[["percent.mito"]] <- PercentageFeatureSet(SO, pattern="^mt-")      # CHANGE THE PATTERN TO FIT ANY SPECIES
SO@meta.data[SO@meta.data$percent.mito > mito.high, "outlier.mito"] <- TRUE
SO@meta.data[SO@meta.data$percent.mito < mito.high, "outlier.mito"] <- FALSE
```

```{r plot-mito, fig.align='default', out.width='50%', fig.show='hold'}
plot1 <- VlnPlot(SO, features = c("percent.mito"), ncol = 3) +
  geom_hline(aes(yintercept = mito.high), color="blue", size=1.5) +
    #geom_hline(aes(yintercept = mito.low), color="orange", size=1.5) +
    ggtitle("Mitochondrial expression\npercentage") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()

plot2 <- VlnPlot(SO, features = c("percent.mito"), ncol = 3) +
    geom_hline(aes(yintercept = mito.high), color="blue", size=1.2) +
    #geom_hline(aes(yintercept = mito.low), color="orange", size=1.2) +
    ylim(0, 12) +
    ggtitle("Mitochondrial expression\npercentage - zoom in") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()

plot1
plot2
```

The cells deleted by this filter are `r dim(SO@meta.data[SO@meta.data$percent.mito > mito.high,])[1]`.


## Percentage of ribosomal reads & cutoffs

```{r addRiboPercentage}
SO[["percent.ribo"]] <- PercentageFeatureSet(SO, pattern="^Rp[sl]")   # SEE IF ANY MODIFICATION IS REQUIRED
SO@meta.data[SO@meta.data$percent.ribo > ribo.low, "outlier.ribo"] <- FALSE
SO@meta.data[SO@meta.data$percent.ribo < ribo.low, "outlier.ribo"] <- TRUE
```

```{r plot-ribo, fig.align = 'center', out.width='50%'}
VlnPlot(SO, features = c("percent.ribo"), ncol = 3) +
  #geom_hline(aes(yintercept = ribo.high), color="blue", size=1.5) +
  geom_hline(aes(yintercept = ribo.low), color="orange", size=1.5) +
    ggtitle("Ribosomal expression\npercentage") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()
```

The cells deleted by this filter are `r dim(SO@meta.data[SO@meta.data$percent.ribo < ribo.low,])[1]`.


## UMI counts thresholds

```{r plot-countRNA, fig.align='default', out.width='50%', fig.show='hold'}
SO@meta.data[, "outlier.nCount"] <- FALSE
SO@meta.data[SO@meta.data$nCount_RNA > max.counts | SO@meta.data$nCount_RNA < min.counts, "outlier.nCount"] <- TRUE
#SO@meta.data[SO@meta.data$nCount_RNA < min.counts, "outlier.nCount"] <- TRUE

plot1 <- VlnPlot(SO, features = c("nCount_RNA"), ncol = 3) +
  geom_hline(aes(yintercept = max.counts), color="purple", size=1.5) +
    geom_hline(aes(yintercept = min.counts), color="green", size=1.5) +
    ggtitle("Read counts per cell") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()
  
plot2 <- VlnPlot(SO, features = c("nCount_RNA"), ncol = 3) +
  geom_hline(aes(yintercept = max.counts), color="purple", size=1.5) +
  geom_hline(aes(yintercept = min.counts), color="green", size=1.5) +
    ylim(0, 25000) +
    ggtitle("Read counts per cell\nzoom in") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()

plot1
plot2
```

The cells deleted by this filter are `r dim(SO@meta.data[SO@meta.data$nCount_RNA < min.counts | SO@meta.data$nCount_RNA > max.counts,])[1]`.


## Number of detected features per cell

```{r plot-featureRNA, fig.align = "center", out.width='50%'}
SO@meta.data[SO@meta.data$nFeature_RNA > min.feat, "outlier.nFeature"] <- FALSE
SO@meta.data[SO@meta.data$nFeature_RNA < min.feat, "outlier.nFeature"] <- TRUE


VlnPlot(SO, features = c("nFeature_RNA"), ncol = 3) +
    geom_hline(aes(yintercept = min.feat), color="#56B4E9", size=1.5) +
    ggtitle("Number of detected features\nper cell") +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_text(angle = 0, size = 18, hjust = 0.5, face = "bold")) +
    NoLegend()
```

The cells deleted by this filter are `r dim(SO@meta.data[SO@meta.data$nFeature_RNA < min.feat,])[1]`.


## Repartition of detected features

Features that are detected in `r min.cells` cells or fewer will be removed from the analysis.

```{r plot-geneRepartition}
# Create dataframe
df <- data.frame(rowSums(SO@assays$RNA@counts != 0))
df$features <- rownames(df)
colnames(df) <- c('Nbr_of_cells', 'features')
rownames(df) <- NULL

## Plot gene expression repartition
ggplot(df, aes(x = Nbr_of_cells)) +
  geom_histogram() +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20)) +
  ylab('Number of features') +
  xlab('Number of cells') +
  scale_x_continuous(trans = "log10") +
  expand_limits(x=c(0,10500), y=c(0,2000)) +
  geom_vline(aes(xintercept = min.cells), color="green", size=1) +
  ggtitle(paste0("Repartition of detected features\n", dataset)) +
  geom_text(aes(x=min.cells,label = paste0("\n", min.cells), y=1800, hjust = 1))
```

Based on this threshold, `r length(which(df$Nbr_of_cells <= min.cells))` features
are removed for the downstream analysis.

## Quality control application

```{r plot-filtering, fig.align='default', out.width='50%', fig.show='hold'}
outliers <- grep("^outlier.", colnames(SO@meta.data), value = TRUE)
qc_param <- c("nCount_RNA", "nFeature_RNA", "percent.mito","percent.ribo")
val <- c("nCount", "nFeature", "mito", "ribo")

plotCols <- list()
for (aValue in val){
    name <- grep(aValue, qc_param, value = TRUE)
    tmp <- grep(aValue, outliers, value = TRUE)
    plotCols[[name]] <- tmp
}

invisible(apply(combn(qc_param, 2), 2, function(x){
    do.call("<-", list(x[1], SO@meta.data[,x[1]]))
    do.call("<-", list(x[2], SO@meta.data[,x[2]]))
    print(ggplot( SO@meta.data, # Plot FALSE first and TRUE after
        aes( x = SO@meta.data[,x[1]],
             y = SO@meta.data[,x[2]],
             color = SO@meta.data[,plotCols[[x[1]]]] | SO@meta.data[,plotCols[[x[2]]]])) +
    geom_point( size = 0.5) +
    labs( x = x[1], y = x[2], color = "Outliers") +
    scale_color_manual( values = c( "TRUE" = "#FF0000AA", "FALSE" = "#44444444")))
}))
```

The cells deleted by application of all the cutoffs are `r dim(SO@meta.data[SO@meta.data$percent.mito > mito.high | SO@meta.data$percent.ribo < ribo.low | SO@meta.data$nCount_RNA < min.counts | SO@meta.data$nCount_RNA > max.counts | SO@meta.data$nFeature_RNA < min.feat,])[1]`

```{r filterQC}
# SO <- subset(SO,
#              features=which(df$Nbr_of_cells > min.cells),
#              subset = percent.mito > mito.low & percent.mito < mito.high & nCount_RNA > min.counts & nCount_RNA < max.counts & nFeature_RNA > min.feat)
SO <- subset(SO,
             features=which(df$Nbr_of_cells > min.cells),
             subset = percent.mito < mito.high & percent.ribo > ribo.low & nCount_RNA > min.counts & nCount_RNA < max.counts & nFeature_RNA > min.feat)
```

```{r size-QCfiltering}
size_track2 <- data.frame(cbind(
    t(dim(SO)),
    "QC filtering",
    "02"
))
colnames(size_track2) <- c('Nbr_of_features', 'Nbr_of_cells', 'Analysis_step_name', 'Step_number')
size_track2$Nbr_of_cells <- as.integer(as.character(size_track2$Nbr_of_cells))
size_track2$Nbr_of_features <- as.integer(as.character(size_track2$Nbr_of_features))
```

```{r plot-evolution1}
ggplot(rbind(size_track1, size_track2), aes(x = Analysis_step_name, y = Nbr_of_cells)) +
  geom_col(aes(color = Analysis_step_name, fill = Analysis_step_name), position = position_dodge(), width = 0.6) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20),
        axis.title.x = element_blank()) +
  scale_x_discrete(labels = label_wrap(6)) +
  ggtitle(paste0("Evolution of the number of cells in the dataset\n", dataset)) +
  NoLegend() +
  ylab('Number of cells')
```

```{r garbage-collec1, include = FALSE}
gc()
```

# Preprocessing workflow before doublet removal

```{r normalization1}
SO <- NormalizeData(SO, normalization.method = norm.meth, verbose=FALSE)
```

```{r show-slots}
data.frame(GetAssayData(SO, slot = "counts")[1:5,1:5]) %>%
  knitr::kable(caption = "Raw counts in 'counts' slot") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "800px", height = "300px")
data.frame(GetAssayData(SO, slot = "data")[1:5,1:5]) %>%
  knitr::kable(caption = "Normalized counts in 'data' slot") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "800px", height = "300px")
```

```{r hvg-vst1, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp"}
SO <- FindVariableFeatures(SO, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
```

```{r hvg-mvp1, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
SO <- FindVariableFeatures(SO, selection.method = hvg.meth, verbose=FALSE)
```


```{r show-HVGnum1, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"}
t(as.data.frame(table(SO@assays[["RNA"]]@meta.features$mvp.variable))) %>%
  knitr::kable(caption = "Number of features selected as highly variable genes (HVG)",
               row.names = FALSE,
               escape = F,
               align = "cc") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r scale1}
SO <- ScaleData(SO, features=rownames(SO), do.scale=TRUE, verbose=FALSE) # do.scale=TRUE to make DoubletFinder working
```

```{r runPCA1, results='hold'}
SO <- RunPCA(SO, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r plot-elbow1}
ElbowPlot(SO, ndims = pca.npcs) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color="purple", size=1) +
  ggtitle(paste0(SO@project.name, "\nElbowPlot"))        
```

```{r clustering1}
resolutions <- seq(0.6, 1.6, 0.2)
SO <- FindNeighbors(SO, dims = 1:top.pcs, verbose=FALSE)
SO <- FindClusters(SO, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
```

```{r runUMAP1}
SO <- RunUMAP(SO, dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE)
```

```{r plot-clusters-1, fig.align='default', out.width="50%", fig.show='hold'}
for (ares in resolutions){
    clusterResName <- grep(paste0("RNA_snn_res.", ares, "$"), colnames(SO@meta.data), value = TRUE)
    dimplotMetadata(SO, clusterResName, title = paste0(dataset, " : clusters at resolution ", ares)) 
    
    Sys.sleep(0.5)
}
```

```{r save1}
saveRDS(SO, file=file.path(rdsObjects, paste0("01_standardWF_", dataset, ".rds")))
```

- - -

\clearpage

```{r setup3, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart1}
SO <- readRDS(file.path(rdsObjects, paste0("01_standardWF_", dataset, ".rds")))
```

```{r setup4, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = TRUE,
    echo = TRUE
)
```

# Doublets identification and removal

Doublets are considered as technical artifacts that have to be filtered out.
In this part, I will use the R package DoubletFinder (REFERENCE PAPIER DOUBLET FINDER).

This tool require the following steps

-   homotypic doublet proportion estimation,

-   pK parameter optimization

to be completed.

## Parameters set up

DoubletFinder relies on 3 main parameters:

-   pN, the number of artificial generated doublets - by default = 0.25

-   pK, the PC neighborhood size used to compute proportion of artificial nearest neighbors (pANN), to be determined

-   nExp, the number of predicted doublets.

### Heterotypic doublets estimation

#### Cell annotation

I directly load a classifier done for 1165 gene markers.
This classifier was generated by the Rossi et al. using the atlas of the Pijuan-Sala et al.

```{r load-classifier}
scmap_classifier <- readRDS(file.path(classifier.folder, "scmap_classifier_1000markers.rds"))
ref_stages <- c("E6.5", "E6.75", "E7.0", "E7.25", "E7.5", "E7.75", "E8.0", "E8.25", "E8.5")
```


```{r classifier-transfert}
set.seed(general.seed)

# create the corresponding SingleCellExperiment object
sce <- as.SingleCellExperiment(x=SO)
rowData(sce)$feature_symbol <- rownames(sce)
counts(sce) <- as.matrix(counts(sce))
logcounts(sce) <- as.matrix(logcounts(sce))

# apply scmapCluster
scmapCluster_results <- scmapCluster(projection=sce, index_list=scmap_classifier[ref_stages], threshold=0)

# add the celltype from the in vivo atlas to the Seurat object
SO <- AddMetaData(object=SO, metadata=scmapCluster_results$combined_labs, col.name="celltype_DF")
```


```{r plot-DF-celltype}
rm(sce)
gc()

dimplotMetadata(SO, "celltype_DF")
```


#### Number of cells to label as doublet (ie. heterotypic doublets)

```{r homotypic-proportion}
# based on annotation (celltype from pijuansala classifier)
# could be also the louvain clusters determined from the preprocessus step
annotations <- SO@meta.data$celltype_DF
homotypic.prop <- modelHomotypic(annotations)
```

```{r heterotypic-estimation}
# based on annotation (celltype from pijuansala classifier)
# could be also the louvain clusters determined from the preprocessus step
nDoublets <- round(ncol(SO)*dblt.rate/100)
nDoublets_nonhomo <- round(nDoublets*(1-homotypic.prop))
```

There are `#r nDoublets_nonhomo` cells estimated as heterotypic doublets.

### Neighborhood size optimization (pK parameter)

```{r generate-pKs, results='hide', fig.show='hide'}
sweep.res <- paramSweep_v3(SO, PCs = 1:top.pcs) # as estimated from PC elbowPlot
sweep.stats_SO <- summarizeSweep(sweep.res, GT = FALSE)
Sys.sleep(0.5)
bcmvn_SO <- find.pK(sweep.stats_SO)
```

```{r optimize-pK}
ggplot(bcmvn_SO, aes(pK, BCmetric, group = 1)) +
  geom_point() +
  geom_line()

pK <- bcmvn_SO %>% # select the pK that corresponds to max bcmvn to optimize doublet detection
  filter(BCmetric == max(BCmetric)) %>%
  select(pK) 
pK <- as.numeric(as.character(pK[[1]]))
```

## Doublets identification - DoubletFinder run

```{r runDF}
SO <- doubletFinder_v3(SO, 
                       PCs = 1:top.pcs, 
                       pN = 0.25,
                       pK = pK, 
                       nExp = nDoublets_nonhomo)
```

```{r plot-doublets}
# remove the cells identified as doublets of each of the sub-datasets
col_dblts <- grep("DF.classifications", colnames(SO@meta.data), value=TRUE)

dimplotMetadata(SO, col_dblts, title = paste0(dataset, " : doublets prediction"))
```

```{r df-count-celltypeDF}
Idents(SO) <- col_dblts
celltypeDF <- as.data.frame.matrix(table(Idents(SO), SO@meta.data$celltype_DF))

celltypeDF %>%
  knitr::kable(caption = "Doublet ratio over celltypes got from Rossi et al. classifier") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")
```

```{r df-count-cluster}
clustersRes <- grep(paste0("res.", res, "$"), colnames(SO@meta.data), value=TRUE)
clusterDF <- as.data.frame.matrix(table(Idents(SO), SO@meta.data[,which(colnames(SO@meta.data) == clustersRes)])) 

clusterDF %>%
  knitr::kable(caption = paste0("Doublet ratio over clusters at resolution ", res)) %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "300px")
```

## Subset to singlets

```{r remove-doublets}
SOsing <- subset(SO, idents='Singlet')

# remove useless columns
SOsing@meta.data[[grep("DF.classifications", colnames(SOsing@meta.data))]] <- NULL
names(SOsing@meta.data)[names(SOsing@meta.data) == grep("pANN", colnames(SOsing@meta.data), value=T)] <- "pANN"
```

```{r size-singlets}
size_track3 <- data.frame(cbind(
    t(dim(SOsing)),
    "Removed doublets",
    "03"
))
colnames(size_track3) <- c('Nbr_of_features', 'Nbr_of_cells', 'Analysis_step_name', 'Step_number')
size_track3$Nbr_of_cells <- as.integer(as.character(size_track3$Nbr_of_cells))
size_track3$Nbr_of_features <- as.integer(as.character(size_track3$Nbr_of_features))
```

```{r plot-evolution2}
ggplot(rbind(size_track1, size_track2, size_track3), aes(x = Analysis_step_name, y = Nbr_of_cells)) +
  geom_col(aes(color = Analysis_step_name, fill = Analysis_step_name), position = position_dodge(), width = 0.6) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size = 20),
        axis.title.x = element_blank()) +
  scale_x_discrete(labels = label_wrap(6)) +
  ggtitle(paste0("Evolution of the number of cells in the dataset\n", dataset)) +
  NoLegend() +
  ylab('Number of cells')
```

<!-- ```{r save2} -->
<!-- saveRDS(SOsing, file=file.path(rdsObjects, paste0("02_removedDoublets_", dataset, ".rds"))) -->
<!-- ``` -->

```{r garbage-collec2, include=FALSE}
rm(SO)
gc()
```

```{r setup5, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

<!-- ```{r restart2} -->
<!-- SOsing <- readRDS(file.path(rdsObjects, paste0("02_removedDoublets_", dataset, ".rds"))) -->
<!-- ``` -->

<!-- ```{r setup6, eval=TRUE, include=FALSE} -->
<!-- knitr::opts_chunk$set( -->
<!--     # code evaluation -->
<!--     eval = TRUE, -->
<!--     echo = TRUE -->
<!-- ) -->
<!-- ``` -->

# Preprocessing workflow after doublets removal

```{r hvg-vst2, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp"}
SOsing <- FindVariableFeatures(SOsing, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
```

<!-- ```{r hvg-mvp2, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"} -->
<!-- SOsing <- FindVariableFeatures(SOsing, selection.method = hvg.meth, verbose=FALSE) -->
<!-- head(SOsing@assays[["RNA"]]@meta.features) %>% -->
<!--   knitr::kable(caption = "Example of HVG selection output") %>% -->
<!--   kable_styling(bootstrap_options = c("striped", "hover")) -->
<!-- ``` -->

<!-- ```{r show-HVGnum2, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"} -->
<!-- t(as.data.frame(table(SOsing@assays[["RNA"]]@meta.features$mvp.variable))) %>% -->
<!--   knitr::kable(caption = "Number of features selected as highly variable genes (HVG)", -->
<!--                row.names = FALSE, -->
<!--                escape = F, -->
<!--                align = "cc") %>% -->
<!--   kable_styling(bootstrap_options = c("striped", "hover")) -->
<!-- ``` -->
 
 
```{r save3-varFeat-dataset, results='hold'}
var.feats.dataset <- VariableFeatures(SOsing)
saveRDS(var.feats.dataset, file=file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds")))

SOsing <- ScaleData(SOsing, features=rownames(SOsing), do.scale=do.scale, verbose=FALSE)
SOsing <- RunPCA(SOsing, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r plot-elbow2}
ElbowPlot(SOsing, ndims = pca.npcs) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color = "purple", size = 1) +
  ggtitle(paste0(SOsing@project.name, "\nElbowPlot"))
```

```{r clustering2}
SOsing@meta.data[grep("RNA_snn", names(SOsing@meta.data))] <- NULL
resolutions <- seq(0.6, 1.6, 0.1)
SOsing <- FindNeighbors(SOsing, dims = 1:top.pcs, verbose=FALSE)
SOsing <- FindClusters(SOsing, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
```

```{r runUMAP2}
SOsing <- RunUMAP(SOsing, dims = 1:top.pcs, seed.use = general.seed, verbose = FALSE)
```

```{r plot-clusters-2, fig.align='default', out.width="50%", fig.show='hold'}
for (ares in resolutions){
    clusterResName <- grep(paste0("RNA_snn_res.", ares, "$"), colnames(SOsing@meta.data), value = TRUE)
    dimplotMetadata(SOsing, clusterResName, title = paste0(dataset, " : clusters at resolution ", ares)) 
    
    Sys.sleep(0.5)
}
```

```{r save4}
saveRDS(SOsing, file=file.path(rdsObjects, paste0("03_WF_onSinglets_", dataset, ".rds")))
```

```{r setup7, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart3}
SOsing <- readRDS(file.path(rdsObjects, paste0("03_WF_onSinglets_", dataset, ".rds")))
```

```{r setup8, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r garbage-collec3, include=FALSE}
gc()
```

- - -

\clearpage

# Transfert learning from an Atlas

## Atlas preparation

```{r atlasLoading}
atlas.metadata <- read.table(file.path(atlas.folder, "meta.tab") , sep="\t" , header=TRUE )
atlas.genes <- read.csv(file.path(atlas.folder, "genes.tsv"), sep="\t", header = FALSE, as.is = TRUE)
atlas.data <- readMM(file.path(atlas.folder, "raw_counts.mtx"))
atlas.data@Dimnames[[2]] <- atlas.metadata$cell
atlas.data@Dimnames[[1]] <- atlas.genes$V2
```

```{r garbage-collec4, include=FALSE}
rm(atlas.genes)
gc()
```

```{r atlasStandardProcess}
atlas <- CreateSeuratObject(counts = atlas.data, project = "Atlas", min.cells=min.cells, min.features = min.feat)
rm(atlas.data)
gc()

nonFiltered <- intersect(colnames(atlas), atlas.metadata$cell)
atlas.metadata <- atlas.metadata[which(atlas.metadata$cell %in% nonFiltered),]

atlas <- NormalizeData(atlas, normalization.method = norm.meth, verbose=FALSE)
atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$stage, col.name = "day")
atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$celltype, col.name = "celltype")
atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$sequencing.batch, col.name = "replicate")
#atlas <- AddMetaData(object = atlas, metadata = atlas.metadata$sequencing.batch+10, col.name = "Replicate")
atlas <- AddMetaData(object = atlas, metadata = paste(atlas$day, "_batch_0", atlas$replicate, sep=""), col.name = "dataset")
atlas$model <- "Embryo"
atlas[["percent.mito"]] <- PercentageFeatureSet(atlas, pattern="^mt-")
atlas[["percent.ribo"]] <- PercentageFeatureSet(atlas, pattern="^Rp[sl]")
```

```{r garbage-collec5, include=FALSE}
rm(atlas.metadata)
gc()
```

```{r atlas_subsetting}
Idents(atlas) <- atlas$day
atlas.subset <- subset(x = atlas, idents = c("mixed_gastrulation"), invert=T)

Idents(atlas.subset) <- atlas.subset$celltype
atlas.subset <- subset(x = atlas.subset, cells = colnames(atlas.subset)[is.na(Idents(atlas.subset))], invert = T)
atlas.subset <- subset(atlas.subset, idents=unique(grep("ExE", atlas.subset$celltype, value = T)), invert=T)
atlas.subset <- subset(atlas.subset, idents="Parietal endoderm", invert=T)
```

```{r garbage-collec6, include=FALSE}
rm(atlas)
gc()
```

## Integrate analyzed data with the Atlas {.tabset .tabset-pills .tabset-fade}

```{r hvg-vst-atlas, eval=hvg.meth != "mvp", echo=hvg.meth != "mvp"}
atlas.subset <- FindVariableFeatures(atlas.subset, nfeatures=hvg.num, selection.method = hvg.meth, verbose=FALSE)
saveRDS(atlas.subset, file.path(rdsObjects, paste0("XX_atlas_before_integ_with_", dataset, ".rds")))
```

<!-- ```{r hvg-mvp-atlas, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp", results='asis'} -->
<!-- atlas.subset <- FindVariableFeatures(atlas.subset, selection.method = hvg.meth, verbose=FALSE) -->
<!-- saveRDS(atlas.subset, file.path(rdsObjects, paste0("XX_atlas_before_integ_with_", dataset, ".rds"))) -->
<!-- ``` -->

<!-- ```{r show-HVGnum-atlas, eval=hvg.meth == "mvp", echo=hvg.meth == "mvp"} -->
<!-- t(as.data.frame(table(atlas.subset@assays[["RNA"]]@meta.features$mvp.variable))) %>% -->
<!--   knitr::kable(caption = "Number of features selected as highly variable genes (HVG)", -->
<!--                row.names = FALSE, -->
<!--                escape = F, -->
<!--                align = "cc") %>% -->
<!--   kable_styling(bootstrap_options = c("striped", "hover")) -->
<!-- ``` -->

```{r integration-with-atlas}
features <- SelectIntegrationFeatures(object.list = list(SOsing, atlas.subset))
anchors <- FindIntegrationAnchors(object.list = list(SOsing, atlas.subset), anchor.features = features)
SO.align <- IntegrateData(anchorset = anchors)

SO.align@project.name <- paste0(dataset, "_with_atlas")
DefaultAssay(SO.align) <- "integrated"

SO.align <- ScaleData(SO.align, assay = DefaultAssay(SO.align), do.scale=do.scale, verbose = FALSE)
SO.align <- RunPCA(SO.align, npcs = pca.npcs, verbose = FALSE)
ElbowPlot(SO.align, ndims = pca.npcs)
```

```{r show-alignedUMAP}
SO.align <- RunUMAP(SO.align, reduction = "pca", dims = 1:10)
dimplotMetadata(SO.align, metadata = "model", title = "Gastruloid and atlas cells\nin a shared UMAP embedding") +
  RestoreLegend()
```

### Cell identity transfert

#### Create a centroid table on Atlas cell types in pca space

```{r classifierCreation}
Idents(SO.align) <- SO.align$model
cells.tmp <- WhichCells(SO.align, idents = "Embryo")
tmp <- SO.align@reductions$pca@cell.embeddings[cells.tmp, 1:top.pcs]
idents.tmp <- SO.align$celltype[cells.tmp]
centroids <- data.frame(row.names = unique(idents.tmp))
for(i in rownames(centroids)){
  for(j in colnames(tmp)){
    centroids[i,j] <- mean(tmp[idents.tmp==i,j])
  }
}
```

#### Apply that knowledge using scmap concept to analyzed data

```{r classifierApplication}
Idents(SO.align) <- SO.align$model
cells.tmp <- WhichCells(SO.align,idents = "Gastruloids")
tmp <- SO.align@reductions$pca@cell.embeddings[cells.tmp, 1:top.pcs]
idents.tmp <- SO.align$celltype[cells.tmp]
idents.tmp[] <- ""
dist <- list()
for(i in names(idents.tmp)){
  for(j in rownames(centroids)){
    dist[[j]] <- cor(x = as.numeric(tmp[i,]),y = as.numeric(centroids[j,]),method = "pearson")
  }
  idents.tmp[i] <- names(which.max(dist))
}

SO.align$orig.celltype <- SO.align$celltype
SO.align$aligned.celltype <- SO.align$celltype
SO.align$aligned.celltype[cells.tmp] <- idents.tmp
SO.align$celltype <- SO.align$aligned.celltype
SO.align$aligned.celltype <- NULL

Idents(SO.align) <- SO.align$celltype
```

<!-- ```{r save5} -->
<!-- saveRDS(SO.align, file=file.path(rdsObjects, paste0("04_celltypeFromAtlas_", SO.align@project.name, ".rds"))) -->
<!-- ``` -->

```{r garbage-collec7, include=FALSE}
rm(centroids, cells.tmp, tmp, idents.tmp, dist)
gc()
```

```{r show-celltypeSOalign}
dimplotMetadata(SO.align, metadata = "celltype", title = "Celltypes on the combined object\nGastruloids and atlas cells")
```

<!-- ```{r setup9, eval=TRUE, include=FALSE} -->
<!-- knitr::opts_chunk$set( -->
<!--     # code evaluation -->
<!--     eval = FALSE, -->
<!--     echo = FALSE -->
<!-- ) -->
<!-- ``` -->

<!-- ```{r restart4} -->
<!-- SO.align <- readRDS(file.path(rdsObjects, paste0("04_celltypeFromAtlas_", dataset,"_with_atlas.rds"))) -->
<!-- atlas.subset <- readRDS(file.path(rdsObjects, paste0("XX_atlas_before_integ_with_", dataset, ".rds"))) -->
<!-- var.feats.dataset <- readRDS(file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds"))) -->
<!-- ``` -->

<!-- ```{r setup10, eval=TRUE, include=FALSE} -->
<!-- knitr::opts_chunk$set( -->
<!--     # code evaluation -->
<!--     eval = TRUE, -->
<!--     echo = TRUE -->
<!-- ) -->
<!-- ``` -->


### Global orientation of the UMAP plots

#### Atlas data preprocessing steps (ScaleData, RunPCA)

```{r scale-atlas}
# Run the standard workflow for visualization and clustering
atlas.subset <- ScaleData(SO.align, assay = DefaultAssay(atlas.subset), do.scale=do.scale, verbose = FALSE)
atlas.subset <- RunPCA(atlas.subset, reduction.name = "PCAown", reduction.key = "PCown_", verbose = FALSE)
gc()
```

#### Get UMAP of a subset of the Atlas data

```{r atlas_refLayout}
spread <- 2
min_dist <- 1
Idents(atlas.subset) <- 'celltype'

# Downsample the number of cells per identity class
set.seed(general.seed)
cells.use <- WhichCells(object = atlas.subset, downsample = 200) #colnames(atlas.subset) #sample(colnames(atlas.subset),1000)
nn=300
local_connectivity=1 # Tried 2 and was not so convincing. Should not be more than the local intrinsic dimension of the manifold.
fast_sgd <- F # Should set it to FALSE ultimately, to get exactly reproducible results, but TRUE can be useful as it is faster for early exploration.
umap_init <- "spectral" # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates.
reduction.use <- "PCAown"

set.seed(general.seed)
tmp <- umap(X = Embeddings(atlas.subset[[reduction.use]])[cells.use, 1:10],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T,
            verbose = F)
tmp2 <- 0*Embeddings(atlas.subset[[reduction.use]])[, 1:3]
tmp2[cells.use, ] <- tmp$embedding
atlas.subset[["umap200"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP200_")
```

UMAP dimension reduction on atlas, with 200 cells per celltype, 300 neighbors

```{r plot-atlasUMAP-200}
DimPlot(atlas.subset, pt.size = 1, reduction = "umap200", label = T, cells = sample(cells.use),
    repel = TRUE, cols = colors.celltype[levels(Idents(atlas.subset))]) +
    NoLegend() +
    ggtitle(paste0(dataset, " : atlas celltypes\nvisualization reduced to 200 cells per celltype")) +
    CenterTitle() +
    NoAxes()
# dimplotMetadata(atlas.subset, "celltype",
#                 title = paste0(dataset, " : atlas celltypes\nvisualization reduced to 200 cells per celltype"),
#                 reduction = "umap200")
```

<!-- ```{r save-atlasUMAP-200} -->
<!-- saveRDS(atlas.subset, file=file.path(rdsObjects, paste0("05_UMAP_atlas_subset200cells_", dataset, ".rds"))) -->
<!-- ``` -->

#### Create a centroid table on Atlas cell types in UMAP200 space

```{r atlas_cluster_avg.pos}
Idents(atlas.subset) <- atlas.subset$celltype
x_ref <- data.frame(row.names = unique(atlas.subset$celltype))
for(i in unique(atlas.subset$celltype)){
  x_ref[i,1] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),1])
  x_ref[i,2] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),2])
  x_ref[i,3] <- mean(atlas.subset[["umap200"]]@cell.embeddings[intersect(cells.use,names(atlas.subset$celltype[atlas.subset$celltype==i])),3])
}
```

#### Create random initial coordinates for the integrated object based on the centroid table

```{r UMAPinit_sharedLayout}
min_dist <- 8
spread <- 25
nn <- 300

# Generate a random position around the layout defined positions for all cells according to their cell types:
noise <- 5
set.seed(general.seed)
x_ini <- data.frame(row.names = colnames(SO.align))
x_ini[,1] <- runif(length(colnames(SO.align)))*noise
x_ini[,2] <- runif(length(colnames(SO.align)))*noise
x_ini[,3] <- runif(length(colnames(SO.align)))*noise
Idents(SO.align) <- SO.align$celltype
for(i in unique(SO.align$celltype)){
  if(i %in% rownames(x_ref)){
    x_ini[WhichCells(SO.align,idents=i),1] <- x_ini[WhichCells(SO.align,idents=i),1]+x_ref[i,1]
    x_ini[WhichCells(SO.align,idents=i),2] <- x_ini[WhichCells(SO.align,idents=i),2]+x_ref[i,2]
    x_ini[WhichCells(SO.align,idents=i),3] <- x_ini[WhichCells(SO.align,idents=i),3]+x_ref[i,3]
  }
}
```

```{r garbage-collec9, include=FALSE}
gc()
```

#### Compute UMAP dimension reduction on the integrated object, nested by the random initial coordinates

```{r apply_UMAPshared}
cells.use <- colnames(SO.align) #WhichCells(object = tmp,downsample = 300) #colnames(SO) #sample(colnames(SO),1000)

local_connectivity=1 # Should not be more than the local intrinsic dimension of the manifold. I would have imagined 2-3 could be reasonable, but doesn't give good results. 
fast_sgd <- T # Should set it to false ultimately, to get exactly reproducible results, but can use T to get faster for early exploration. 
umap_init <- as.matrix(x_ini[cells.use,]) # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates. 

set.seed(general.seed)
reduction.use <- "pca"
tmp <- umap(X = Embeddings(SO.align[[reduction.use]])[cells.use, 1:10],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T, 
            verbose = F)
tmp2 <- 0*Embeddings(SO.align[[reduction.use]])[,1:3]
tmp2[cells.use,] <- tmp$embedding
SO.align[["umapShared3d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAPshared3d_", assay = DefaultAssay(SO.align))


umap_init <- as.matrix(x_ini[cells.use, 1:2]) # "normlaplacian", "spectral" (with noise),  "random", "lvrandom" (Gaussian std 1e-4), "laplacian", or a matrix of initial coordinates. 

set.seed(general.seed)
reduction.use <- "pca"
tmp <- umap(X = Embeddings(SO.align[[reduction.use]])[cells.use, 1:10],
            init = umap_init,
            n_neighbors = nn,
            n_components = 2,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            init_sdev = 1e-4,
            local_connectivity = local_connectivity,
            ret_model=T, 
            verbose = F)
tmp2 <- 0*Embeddings(SO.align[[reduction.use]])[,1:2]
tmp2[cells.use,] <- tmp$embedding
SO.align[["umapShared2d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAPshared2d_", assay = DefaultAssay(SO.align))
```

```{r plot-SOalign-umapShared2d}
DimPlot(SO.align, pt.size = 1, reduction = "umapShared2d", label = T, 
    repel = TRUE, cols = colors.celltype[levels(Idents(atlas.subset))]) + 
    NoLegend() +
    ggtitle(paste0(dataset, " : celltype layout\non the integrated object")) +
    CenterTitle() +
    NoAxes()
```

```{r save6}
saveRDS(SO.align, file=file.path(rdsObjects, paste0("05_UMAP_shared_", SO.align@project.name, ".rds")))
```

```{r garbage-collec10, include=FALSE}
rm(tmp, tmp2, cells.use, x_ref, x_ini)
gc()
```

```{r setup11, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart5}
SO.align <- readRDS(file.path(rdsObjects, paste0("05_UMAP_shared_", dataset, "_with_atlas.rds")))
var.feats.dataset <- readRDS(file=file.path(rdsObjects, paste0("var.feats.dataset_", dataset, ".rds")))
```

```{r setup12, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

# `r dataset` data analysis after label transfert and initialized UMAP coordinates

```{r extract-dataset}
cells.use <- colnames(SO.align)[SO.align$model == "Gastruloids"]
SO <- SO.align[, cells.use]
SO@project.name <- dataset
```

```{r set-DefaultAssay}
DefaultAssay(SO) <- "RNA"
```

## Analyzed data preprocessing

```{r set-HVG, results='hold'}
VariableFeatures(SO) <- var.feats.dataset
SO <- ScaleData(SO, features=rownames(SO), do.scale=do.scale, verbose=FALSE)
SO <- RunPCA(SO, npcs = pca.npcs, nfeatures.print = pca.print, seed.use = general.seed, verbose=TRUE)
```

```{r plot-elbow3}
ElbowPlot(SO, ndims = pca.npcs) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20)) +
  geom_vline(aes(xintercept = top.pcs), color="purple", size=1) +
  ggtitle(paste0(SO@project.name, "\nElbowPlot"))        
```

## Run UMAP algorithm, nested on atlas coordinates

```{r UMAP-dataset}
# Create 3-dimensional UMAP coordinates
SO[["umapShared3d"]] <- CreateDimReducObject(embeddings = Embeddings(SO.align$umapShared3d)[cells.use,], key = "UMAPshared3d_", assay = DefaultAssay(SO))

init_sdev <- 1e-4
noise_level <- 0
min_dist <- 6
spread <- 15
nn <- 300

umap_init <- as.matrix(Embeddings(SO[["umapShared3d"]]))
set.seed(general.seed)
umap_init <- umap_init + cbind(rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level))
set.seed(general.seed)
reduction.use <- "pca" # pca1 or harmony
tmp <- umap(X = Embeddings(SO[[reduction.use]])[colnames(SO), 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 3,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            local_connectivity=1,
            ret_model=T,
            verbose = F,
            n_epochs = 1000,
            learning_rate = 1,
            init_sdev = init_sdev)

tmp2 <- 0*Embeddings(SO[["pca"]])[,1:3]
tmp2[colnames(SO),] <- tmp$embedding
SO[["umap3d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP3d_", assay = DefaultAssay(SO))

# Create 2-dimensional UMAP coordinates
SO[["umapShared2d"]] <- CreateDimReducObject(embeddings = Embeddings(SO.align$umapShared2d)[cells.use,], key = "UMAPshared2d_", assay = DefaultAssay(SO))

umap_init <- as.matrix(Embeddings(SO[["umapShared2d"]]))
set.seed(general.seed)
umap_init <- umap_init + cbind(rnorm(nrow(umap_init),sd = noise_level),
                               rnorm(nrow(umap_init),sd = noise_level))
set.seed(general.seed)
reduction.use <- "pca" # pca1 or harmony
tmp <- umap(X = Embeddings(SO[[reduction.use]])[colnames(SO), 1:top.pcs],
            init = umap_init,
            n_neighbors = nn,
            n_components = 2,
            metric = "cosine",
            min_dist = min_dist,
            spread = spread,
            local_connectivity=1,
            ret_model=T,
            verbose = F,
            n_epochs = 1000,
            learning_rate = 1,
            init_sdev = init_sdev)

tmp2 <- 0*Embeddings(SO[["pca"]])[,1:2]
tmp2[colnames(SO),] <- tmp$embedding
SO[["umap2d"]] <- CreateDimReducObject(embeddings = tmp2, key = "UMAP2d_", assay = DefaultAssay(SO))
```

```{r save7}
saveRDS(SO, file=file.path(rdsObjects, paste0("06_umap_2d3d_", SO@project.name, ".rds")))
```

```{r garbage-collec11, include=FALSE}
rm(umap_init, tmp, tmp2)
gc()
```

```{r show-umap2d}
dimplotMetadata(SO, "celltype",
                title = paste0("Gastruloid cells in UMAP embbeding\nnested on atlas UMAP coordinates"),
                reduction = "umap2d")
```

```{r setup13, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart6}
SO <- readRDS(file.path(rdsObjects, paste0("06_umap_2d3d_", SO@project.name, ".rds")))
```

```{r setup14, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

## Clustering (FindNeighbors, FindClusters)

```{r clustering3}
resolutions <- seq(0.6, 1.6, 0.1)
SO <- FindNeighbors(SO, dims = 1:top.pcs, verbose=FALSE)
SO <- FindClusters(SO, resolution = resolutions, algorithm = algo.cluster, random.seed = general.seed, verbose=FALSE)
```

```{r save8}
saveRDS(SO, file=file.path(rdsObjects, paste0("07_clusters_", SO@project.name, ".rds")))
```

```{r garbage-collec12, include=FALSE}
gc()
```

```{r show-clustering}
selectedRes <- grep(paste0(DefaultAssay(SO), ".*res.", res, "$"), colnames(SO@meta.data), value=TRUE)
Idents(SO) <- SO@meta.data[[selectedRes]]
dimplotMetadata(SO, selectedRes,
                reduction = "umap2d")
```

```{r setup15, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart7}
SO <- readRDS(file.path(rdsObjects, paste0("07_clusters_", dataset, ".rds")))
```

```{r setup16, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

## Differential expression analysis

```{r selected-resolution}
#SO$seurat_clusters <- NULL
selectedRes <- grep(paste0(DefaultAssay(SO), ".*res.", res, "$"), colnames(SO@meta.data), value=TRUE)
SO$clusters <- SO[[selectedRes]]
Idents(SO) <- SO$clusters
```

```{r findAllMarkers}
DefaultAssay(SO) <- 'RNA'

markers <- FindAllMarkers(SO, only.pos = TRUE)
#markers.sign <- markers[markers$p_val_adj < 0.001 & markers$avg_logFC > log(1.5), ]
markers.sign <- markers[order(-markers$avg_log2FC), ]
markers.sign <- markers.sign[order(markers.sign$cluster), ]
markers.sign <- markers.sign[ , c(6, 7, 2:4, 1, 5)]
write.table(x = markers.sign, file = file.path(dataset.anFolder,
						paste0("markers_min.pct_logFC_default_", 
                                            dataset, ".integ.res_", selectedRes, ".csv")), sep = ",", row.names = F, col.names = T)
```

```{r topNmarkers}
topNmarkers <- extract_topn(markers.sign, topn = top.markers)

dominantCelltypes <- add_dominantMetadata(SO, metadata = "celltype")
topNmarkers <- left_join(topNmarkers, dominantCelltypes, by='cluster')
```

```{r addDay_dominantMetadata, eval=(do.integ || do.merge), echo=(do.integ || do.merge)}
dominantDays <- add_dominantMetadata(SO, metadata = "day")
topNmarkers <- left_join(topNmarkers, dominantDays, by='cluster')
```

```{r saveTopNmarkers}
write.table(x = topNmarkers, file = file.path(dataset.anFolder, paste0("top_", top.markers, "_markers.csv")), sep = ",", row.names = F, col.names = T)
```

```{r displayTable}
datatable(topNmarkers, rownames = FALSE, filter = "top", options = list(pageLength = 5, scrollX=T))
```

```{r setup17, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

```{r restart8}
SO <- readRDS(file.path(rdsObjects, paste0("07_clusters_", dataset, ".rds")))
selectedRes <- grep(paste0(DefaultAssay(SO), ".*res.", res, "$"), colnames(SO@meta.data), value=TRUE)
markers.sign <- read.table(file.path(dataset.anFolder, paste0("markers_min.pct_logFC_default_", dataset, ".integ.res_", selectedRes, ".csv")), sep = ",", header = T)
```

```{r setup18, eval=TRUE, include=FALSE}
knitr::opts_chunk$set(
    # code evaluation
    eval = FALSE,
    echo = FALSE
)
```

# Additional Plots

```{r addPlots-1}
# Load list of genes of interest
goi <- read.table(file.path(otherInputs, "genes_of_interest3-scRNAseq.tsv"), sep = ",")
goiList <- goi$V1

# Parameters
ntop <- 5
```

```{r addPlots-2}
DefaultAssay(SO) <- "RNA"
topNmarkers <- extract_topn(markers.sign, topn = ntop)
topNgenes <- unique(topNmarkers$gene)
```

```{r clean-goiList}
genesToRemove <- goiList[!(goiList %in% rownames(SO))]
if (length(genesToRemove) >= 1){
    cat(paste0("One or more genes of interest are not in the dataset (maybe because of the case):\n\t",
                 str_c(genesToRemove, collapse = ", "), "\nThe listed genes are to be removed of the plots"))
}
goiList <- goiList[goiList %in% rownames(SO)] # remove the 
```

## Cluster identity {.tabset .tabset-pills .tabset-fade}

```{r addPlots-3}
Idents(SO) <- factor(SO@meta.data$RNA_snn_res.1, levels = sort(as.numeric(levels(as.factor(SO@meta.data$RNA_snn_res.1)))))
```

### DimPlot of the cluster identity
```{r cluster-dimplot}
createDimPlot(SO, title = paste0("Clusters at resolution 1\n", SO@project.name))
```

### DotPlot of the markers on cluster identity

```{r cluster-dotPlot-markers}
dotPlotsMarkers(SO, topNgenes, title=paste0("Top ", ntop, " markers of each cluster in clusters"))
```

### DotPlot of the genes of interest on cluster identity

```{r cluster-dotPlot-goi}
dotPlotsGoi(SO, goiList, title="Genes of interest in clusters")
```

### FeaturePlot of the markers {.tabset .tabset-pills .tabset-fade}

```{r results='asis', out.width='20%', fig.align='default'}
# code with the courtesy of Lionel Spinelli and Romain Fenouil
topMarkers = by( markers.sign, markers.sign[["cluster"]], function(x)
{
  # Filter markers based on adjusted PValue
  x = x[ x[["p_val_adj"]] < 0.005, , drop = FALSE];
  # Sort by decreasing logFC
  x = x[ order(abs(x[["avg_log2FC"]]), decreasing = TRUE), , drop = FALSE ]
  # Return top ones
  return( if(is.null(  top.markers )) head( x, n =  10 ) else head( x, n =  min(top.markers, 10) ));
});

clustersColor <- setNames(hue_pal()(length(names(topMarkers))), names(topMarkers))

invisible( lapply( names( topMarkers), function(clusterName)
{
  cat("##### Cluster <span style='border-radius: 3px; border: 3px solid ", clustersColor[clusterName], "; padding:0px 2px'>", clusterName, "</span>\n");

  # Highlight cells of current cluster on a dimreduc plot
  highlightClusterPlot(clusterName, seuratObject = SO, reduction = ifelse( exists("useReduction"), useReduction, "umap2d"));

  # Plots expression on projected cells
  invisible( lapply( topMarkers[[clusterName]][["gene"]], function(featureName)
    {
      print( FeaturePlot( SO, features = featureName, reduction = ifelse( exists("useReduction"), useReduction, "umap2d"), order = TRUE) +
               theme( axis.title.x = element_blank(),
                      axis.title.y = element_blank(),
                      legend.position = "none"));
    }));

  cat(" \n \n"); # Required for '.tabset'
}))
```

<!-- ```{r cluster-featurePlot-markers} -->
<!-- ## FeaturePlot the genes of interest -->
<!-- doFeaturePlot(SO, topNgenes) -->
<!-- ``` -->

### FeaturePlot of the genes of interest with cluster labels

```{r cluster-featurePlot-goi}
## FeaturePlot the genes of interest
doFeaturePlot(SO, goiList)
```

### ViolinPlots of the markers {tabset .tabset-pills .tabset-fade}

```{r results='asis'}
# with courtesy of Lionel Spinelli and Romain Fenouil
invisible( lapply( names( topMarkers), function(clusterName)
{
  cat("##### Cl. <span style='border-radius: 3px; border: 3px solid ", clustersColor[clusterName], "; padding:0px 2px'>", clusterName, "</span>\n");

  # Remind cluster name in an empty figure to keep consistent alignment of panels between tabs
  plot( c( 0, 1), c( 0, 1), ann = F, bty = 'n', type = 'n', xaxt = 'n', yaxt = 'n');
  text( x = 0.5, y = 0.5, paste( "Cluster", clusterName), cex = 2, col = clustersColor[clusterName]);

  # Violinplot for expression value of marker genes by cluster (+ number of 'zero' and 'not zero' cells)
  invisible( lapply( topMarkers[[clusterName]][["gene"]], violinFeatureByCluster, seuratObject = SO, clustersColor = clustersColor));

  cat(" \n \n"); # Required for '.tabset'
}));
```

## Celltype identity {.tabset .tabset-pills .tabset-fade}

```{r addPlots-4}
Idents(SO) <- factor(SO@meta.data$celltype, levels = sort(levels(as.factor(SO@meta.data$celltype))))
```

### DimPlot of the celltype identity

```{r celltype-dimplot}
## DimPlot the celltype
createDimPlot(SO, title=paste0("Celltype from atlas transfert identity labels\n", SO@project.name),
              cols=colors.celltype[levels(Idents(SO))]) +
    NoLegend()
```

### DotPlot of the markers on celltype identity

```{r celltype-dotPlot-markers}
## DotPlot the n-top markers of each celltype
dotPlotsMarkers(SO, topNgenes, title=paste0("Top ", ntop, " markers of each cluster in celltypes"))
```

### DotPlot of the genes of interest on celltype identity

```{r celltype-dotPlot-goi}
## DotPlot the genes of interest
dotPlotsGoi(SO, goiList, title="Genes of interest in celltypes")
```

